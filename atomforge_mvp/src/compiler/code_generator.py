import json
from dataclasses import asdict
from datetime import date, datetime
from pymatgen.core import Lattice as PmgLattice, Structure
from pymatgen.io.vasp import Poscar
from pymatgen.io.cif import CifWriter
from ..parser.atomforge_ir import AtomForgeFile, AtomSpec, Lattice, Symmetry, Site, Species

class CodeGenerator:
    """
    Traverses the AtomForge IR to emit computational specifications:
      1. JSON for materials databases.
      2. VASP POSCAR input.
      3. CIF file.
    """
    def __init__(self, ir: AtomForgeFile):
        self.ir = ir

    def generate_json(self) -> str:
        """
        Produce a JSON representation of the AtomForgeFile for ingestion by materials databases.
        """
        # Convert dataclasses to native Python structures
        raw = asdict(self.ir)
        # Optionally, remove None or empty entries
        def clean(obj):
            if isinstance(obj, (date, datetime)):
                return obj.isoformat()
            if isinstance(obj, dict):
                return {k: clean(v) for k, v in obj.items() if v is not None and v != []}
            if isinstance(obj, list):
                return [clean(v) for v in obj]
            return obj
        cleaned = clean(raw)
        return json.dumps(cleaned, indent=2)

    def generate_poscar(self) -> str:
        """
        Emit a VASP POSCAR string using pymatgen.
        """
        spec: AtomSpec = self.ir.spec
        # Build the lattice
        lat: Lattice = spec.lattice
        lattice = PmgLattice.from_parameters(
            lat.a, lat.b, lat.c,
            lat.alpha, lat.beta, lat.gamma
        )
        # Build species and coords lists
        species_symbols = []
        frac_coords = []
        for site in spec.basis:
            for sp in site.species:
                species_symbols.append(sp.element)
                frac_coords.append(site.position)
        # Create a Structure
        struct = Structure(
            lattice,
            species_symbols,
            frac_coords,
            coords_are_cartesian=False
        )
        poscar = Poscar(struct)
        return poscar.get_string()

    def generate_cif(self) -> str:
        """
        Emit a CIF file string using pymatgen.
        """
        spec: AtomSpec = self.ir.spec
        lat: Lattice = spec.lattice
        lattice = PmgLattice.from_parameters(
            lat.a, lat.b, lat.c,
            lat.alpha, lat.beta, lat.gamma
        )
        species_symbols = []
        frac_coords = []
        for site in spec.basis:
            for sp in site.species:
                species_symbols.append(sp.element)
                frac_coords.append(site.position)
        struct = Structure(
            lattice,
            species_symbols,
            frac_coords,
            coords_are_cartesian=False
        )
        writer = CifWriter(struct)
        return writer.__str__()

    # VASP Input Generators
    def generate_incar(self) -> str:
        """
        Emit a VASP INCAR file string based on property_validation.
        """
        spec = self.ir.spec
        pv = spec.property_validation
        lines = []
        # System name
        lines.append(f"SYSTEM = {spec.name}")
        # Functional
        if pv and hasattr(pv, 'computational_backend'):
            cb = pv.computational_backend
            # Expect cb as dict-like or dataclass with attributes functional, energy_cutoff, k_point_density
            functional = getattr(cb, 'functional', None)
            if functional:
                lines.append(f"GGA = {functional}")
            encut = getattr(cb, 'energy_cutoff', None)
            if encut:
                lines.append(f"ENCUT = {encut}")
        # Precision and convergence
        lines.append("PREC = Accurate")
        if pv and getattr(pv, 'convergence_criteria', None):
            cc = pv.convergence_criteria
            etol = getattr(cc, 'energy_tolerance', None)
            if etol:
                lines.append(f"EDIFF = {etol}")
        # Add defaults
        lines.append("ISMEAR = 0")
        lines.append("SIGMA = 0.05")
        return " ".join(lines)

    def generate_kpoints(self) -> str:
        """
        Emit a VASP KPOINTS file string using a simple Monkhorst-Pack grid.
        """
        spec = self.ir.spec
        # Default grid size from computational_backend
        grid = None
        pv = spec.property_validation
        if pv and hasattr(pv, 'computational_backend'):
            grid = getattr(pv.computational_backend, 'k_point_density', None)
        # Fallback to 1x1x1 if not provided
        try:
            k = int(grid) if grid else 1
        except Exception:
            k = 1
        lines = [
            "KPOINTS generated by AtomForge",
            "0",
            "Monkhorst-Pack",
            f"{k} {k} {k}",
            "0 0 0"
        ]
        return " ".join(lines)

    def generate_potcar(self) -> str:
        """
        Emit a simple POTCAR reference list for each unique element.
        """
        spec = self.ir.spec
        elements = []
        for site in spec.basis:
            for sp in site.species:
                if sp.element not in elements:
                    elements.append(sp.element)
        # Construct POTCAR entries
        lines = [f"POTCAR for {el}: PAW_PBE {el}" for el in elements]
        return " ".join(lines)
