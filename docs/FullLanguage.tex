/*======================================================================*
  AtomForge DSL – Extended EBNF (v2025-05-08, Release 2.1 — Production Standard)
  ======================================================================*
  AtomForge: A Domain-Specific Language for Inorganic Repetitive Structures
  
  Release 2.1 - "Production Standard" for comprehensive materials specification:
  - Universal scope: All inorganic repetitive structures (crystals, surfaces, 
    interfaces, defects, amorphous regions, nanostructures)
  - Revolutionary patching mechanism for structure modification workflows
  - Multi-frame coordinate handling with explicit frame management
  - Comprehensive provenance tracking for reproducible materials research
  - Integration with AI/ML pipelines through standardized representation
  - Support for advanced features: superspace structures, environmental coupling,
    complex defect modeling, and materials property embedding
  
  DESIGN PHILOSOPHY:
  AtomForge bridges the gap between human intuition and machine precision in
  materials design. While retaining full technical rigor for computational
  workflows, the language prioritizes clarity and extensibility to enable
  the next generation of AI-driven materials discovery platforms.
  
  TARGET APPLICATIONS:
  - Computational materials workflows (DFT, MD, MC simulations)
  - Materials informatics and machine learning datasets
  - High-throughput materials screening pipelines
  - Educational tools for crystallography and materials science
  - Industry-standard data exchange for materials databases
  - Integration with experimental characterization platforms
  ======================================================================*/

/***********************  LEXICAL RULES & ERROR HANDLING  *********************/
(* ============================================================================
   LEXER IMPLEMENTATION NOTES & PRECISE ERROR REPORTING
   ============================================================================
   The following complex parsing rules are handled by the lexer's state machine
   and are outside the scope of this context-free grammar:
   
   STRING PARSING:
   - Multi-line string content parsing with embedded quotes
   - Escape sequence processing within strings (\n, \t, \", \\, \u{xxxx})
   - Unicode character validation and UTF-8 encoding compliance
   
   NUMERIC PARSING:
   - Scientific notation with automatic precision detection
   - Unit-aware numeric literals with dimensional validation
   - Automatic detection of integer vs floating-point context
   
   PRECISE ERROR RECOVERY POSITIONS:
   The lexer provides exact error locations for IDE integration and debugging:
   
   Error Format: [filename]:[line]:[column]: [error_type]: [message]
   Example: battery_cathode.atomforge:42:15: LexError: Unclosed string literal
                                                     ^
   Column Precision:
   - UTF-8 aware character counting (not byte positions)
   - Tab expansion using configurable tab width (default: 4 spaces)
   - Multi-byte Unicode characters counted as single columns
   - Zero-indexed internally, one-indexed in error messages
   
   IDE Integration Support:
   - Language Server Protocol (LSP) compatible error reporting
   - VS Code extension ready with syntax highlighting and error squiggles
   - IntelliJ/PyCharm plugin support with quick-fix suggestions
   - Emacs/Vim integration with jump-to-error functionality
   
   EDGE CASE HANDLING:
   - Malformed structures: Lexer reports missing braces with context
   - Invalid coordinate values: Precision loss warnings for extreme values
   - Unit inconsistencies: Dimensional analysis errors with suggestions
   - Element symbol validation: Suggests corrections for typos
   - Coordinate frame mismatches: Clear error messages with frame expectations
   
   LEXER PRIORITY RULES (Resolves Identifier vs Keyword Ambiguity):
   1. Keywords (crystal_spec, header, lattice, etc.) matched with highest priority
   2. Element symbols (H, He, Li, ...) recognized as atomic literals
   3. Identifiers matched only if no keyword or element symbol matches
   4. Unit identifiers use lookahead to distinguish from regular identifiers
   5. Frame specifiers (fractional, cartesian) context-sensitive matching
   
   ERROR RECOVERY:
   - Lexer continues after errors to find multiple issues in single pass
   - Provides "did you mean?" suggestions for near-matches to keywords
   - Reports expected token types when encountering unexpected characters
   - Panic mode recovery: skips to next block boundary after lexical error
   ============================================================================ *)

WS            ::= ( ' ' | '\t' | '\r' | '\n' )+ ;          (* skipped *)
CommentLine   ::= '#' [^'\n']* Newline ;                   (* skipped *)
CommentBlk    ::= '/*' CommentBody '*/' ;                   (* skipped *)
CommentBody   ::= ( ! '*/' . )* ;                           (* no nesting *)

/****  The scanner MUST skip { WS | CommentLine | CommentBlk } between tokens  ****/

/***********************  TOP-LEVEL STRUCTURE  ***********************/
(* ============================================================================
   ATOMFORGE PROGRAM STRUCTURE & DESIGN RATIONALE:
   
   The top-level Program structure follows a dependency-ordered layout:
   1. Header: Metadata and versioning for reproducibility
   2. Description: Human-readable context (optional but recommended)
   3. Units: Dimensional system specification
   4. Lattice: Fundamental geometric foundation
   5. Symmetry: Space group and crystallographic symmetry
   6. Basis: Atomic positions and species (the core structural data)
   7. Advanced Features: Defects, transformations, properties, etc.
   8. Provenance: Data lineage and computational history
   9. Patching: Structure modification and version control
   
   DESIGN PRINCIPLES:
   - Mandatory core: Header, Lattice, Symmetry, Basis (minimum viable structure)
   - Optional extensions: All other blocks enable advanced use cases
   - Dependency validation: Compiler ensures referenced entities exist
   - Extensibility: Meta block allows arbitrary user-defined metadata
   
   REAL-WORLD EXAMPLES:
   
   Simple Crystal (Minimal):
     atom_spec "silicon_diamond" {
       header { dsl_version = "2.1", title = "Silicon Diamond", created = 2025-05-08 }
       lattice { type = cubic, a = 5.431 }
       symmetry { space_group = 227 }
       basis {
         site "Si1" { wyckoff = "8a", position = (0.0, 0.0, 0.0), 
                      frame = fractional, species = ({ element = "Si", occupancy = 1.0 }) }
       }
     }
   
   Complex Battery Material (Full Featured):
     atom_spec "LiFePO4_cathode" {
       header { 
         dsl_version = "2.1", title = "LiFePO4 Olivine Cathode",
         created = 2025-05-08, uuid = "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
       }
       description = "Olivine-structured lithium iron phosphate for Li-ion batteries"
       units { system = "crystallography_default", length = angstrom, angle = degree }
       lattice { type = orthorhombic, a = 10.334, b = 6.008, c = 4.693 }
       symmetry { space_group = "Pnma", origin_choice = 1 }
       basis { (* detailed atomic sites with magnetic moments *) }
       defects { (* Li vacancies for delithiation modeling *) }
       environment { temperature = 298 K, e_field = (0, 0, 0.1) cartesian "V/m" }
       properties { 
         band_gap = 1.8, (* eV *)
         ionic_conductivity = 1e-6 (* S/cm *)
       }
       provenance {
         source = "DFT+U calculation", method = "PBE+U, U_eff = 4.3 eV",
         doi = "10.1038/nature12345"
       }
     }
   
   ERROR HANDLING:
   - Missing mandatory blocks trigger clear error messages
   - Circular dependencies detected and reported
   - Invalid references to undefined entities caught at parse time
   - Dimensional consistency validated across all blocks
   ============================================================================ *)
Program ::= "atom_spec" Identifier "{" Header ( "description" "=" Str "," )?
             Units? TypeSystem? Lattice Symmetry Basis
             EmergingMaterials? Defects? Tile? Bonds? Elastic? Phonon? Density? Environment?
             AIIntegration? ProceduralGeneration? Benchmarking? Properties? Validation? Simplification? Provenance? Patch? Meta? "}" ;

/*----------------------------  HEADER & METADATA -------------------------*/
(* ============================================================================
   HEADER BLOCK WITH VERSIONING & UUID SUPPORT:
   
   The header serves multiple critical functions:
   1. DSL version compatibility for parsing different language versions
   2. Content schema versioning for data format evolution
   3. Unique identification for version control and citation
   4. Temporal tracking for data provenance and audit trails
   
   VERSIONING STRATEGY:
   - dsl_version: Semantic versioning (major.minor.patch)
     * Major: Breaking syntax changes
     * Minor: New features, backward compatible
     * Patch: Bug fixes, clarifications
   - content_schema_version: User-defined for domain-specific evolution
   - UUID: RFC 4122 compliant for global uniqueness
   
   PRACTICAL EXAMPLES:
   
   Research Publication:
     header {
       dsl_version = "2.1",
       content_schema_version = "battery_materials_v1.2",
       uuid = "f47ac10b-58cc-4372-a567-0e02b2c3d479",
       title = "High-Voltage Spinel Cathode Materials",
       created = 2025-05-08,
       modified = 2025-05-15
     }
   
   Industrial Database Entry:
     header {
       dsl_version = "2.1",
       uuid = "550e8400-e29b-41d4-a716-446655440000",
       title = "Alloy_Steel_316L_Composition",
       created = 2025-03-15
     }
   
   VERSION COMPATIBILITY:
   - Parser validates dsl_version against supported versions
   - Forward compatibility: newer parsers can read older versions
   - Breaking changes increment major version
   - Migration tools provided for major version upgrades
   ============================================================================ *)
Header ::= "header" "{" "dsl_version" "=" Str "," "content_schema_version"? "=" Str ","
                       "uuid"? "=" Str "," "title" "=" Str ","
                       "created" "=" Date "," "modified"? "=" Date "}" ;

(* ============================================================================
   UNITS SYSTEM WITH DIMENSIONAL ANALYSIS:
   
   The units system provides dimensional consistency checking and automatic
   unit conversion throughout the specification. Supports both standard
   crystallographic units and custom scientific units.
   
   STANDARD SYSTEMS:
   - "crystallography_default": angstrom, degree, K, GPa, angstrom^2
   - "SI": meter, radian, K, Pa, meter^2
   - "atomic": bohr, radian, hartree, hartree/bohr^2
   - "custom": user-defined unit system
   
   DIMENSIONAL VALIDATION:
   - Length units: angstrom, nm, pm, bohr, meter
   - Angle units: degree, radian, grad
   - Temperature: K, Celsius, Fahrenheit
   - Pressure: Pa, kPa, MPa, GPa, bar, atm, psi
   - Displacement: angstrom^2, pm^2, bohr^2
   
   CUSTOM UNIT EXAMPLES:
   
   Materials Science Units:
     units {
       system = "materials_science",
       length = angstrom,     (* Crystal structure lengths *)
       angle = degree,        (* Lattice angles *)
       disp = "angstrom^2",   (* Atomic displacement parameters *)
       temp = K,              (* Temperature *)
       pressure = GPa,        (* Mechanical properties *)
       energy = eV,           (* Electronic properties *)
       current = mA,          (* Electrochemical measurements *)
       concentration = "mol/L" (* Solution chemistry *)
     }
   
   Computational Units:
     units {
       system = "computational",
       length = bohr,         (* Atomic units for DFT *)
       angle = radian,        (* Mathematical preference *)
       energy = hartree,      (* Quantum mechanical energy *)
       time = "fs",           (* Molecular dynamics timescale *)
       force = "hartree/bohr" (* Atomic forces *)
     }
   
   ERROR HANDLING:
   - Inconsistent units detected across all expressions
   - Automatic unit conversion when possible
   - Clear error messages for dimensional mismatches
   - Suggestions for compatible unit choices
   ============================================================================ *)
Units  ::= "units" "{" "system" "=" Str "," "length" "=" LenU "," "angle" "=" AngU ","
                       "disp" "=" DispU "," "temp" "=" TempU ","
                       "pressure" "=" PresU "}" ;

/*----------------------------  TYPE SYSTEM FOR COMPATIBILITY -------------------------*/
(* ============================================================================
   ADVANCED TYPE SYSTEM INSPIRED BY METAGEN:
   
   Following MetaGen's successful use of types for ensuring skeleton-lifting
   compatibility, AtomForge provides a comprehensive type system for validating
   structural compatibility, chemical reasonableness, and computational feasibility.
   
   TYPE CATEGORIES:
   
   1. STRUCTURAL TYPES:
      - Coordination environments (tetrahedral, octahedral, square_planar, etc.)
      - Crystal systems (cubic, hexagonal, orthorhombic, etc.)
      - Connectivity patterns (3D_network, layered, molecular, chain)
   
   2. CHEMICAL TYPES:
      - Element categories (alkali_metal, transition_metal, halogen, etc.)
      - Oxidation state patterns (variable_valence, fixed_valence)
      - Bonding characteristics (ionic, covalent, metallic, mixed)
   
   3. COMPUTATIONAL TYPES:
      - Calculation methods (DFT_compatible, force_field_ready, ML_trainable)
      - Simulation requirements (periodic_boundary, finite_cluster, surface)
      - Approximation levels (minimal_basis, converged, production_quality)
   
   COMPATIBILITY RULES:
   The type system enforces compatibility between different structural components
   and ensures that only chemically and physically reasonable combinations
   are allowed.
   
   PRACTICAL EXAMPLES:
   
   Structural Type Checking:
     type_system {
       structural_types = {
         coordination_environment = "octahedral",
         crystal_system = "cubic",
         space_group_family = "face_centered",
         connectivity = "3D_network"
       },
       compatibility_rules = [
         "octahedral + cubic - allowed",
"octahedral + coordination_number_6 - required",
"face_centered + minimum_symmetry_operations - verified"
       ]
     }
   
   Chemical Type Validation:
     type_system {
       chemical_types = {
         central_atom = {
           element_category = "transition_metal",
           oxidation_states = [2, 3, 4],
           coordination_preference = ["octahedral", "square_planar"]
         },
         ligands = {
           element_category = "chalcogen",
           bonding_type = "ionic_covalent_mixed",
           coordination_number = [2, 3]
         }
       },
       validation_rules = [
         "charge_balance_required",
         "electronegativity_compatibility",
         "ionic_radius_consistency"
       ]
     }
   
   Computational Compatibility:
     type_system {
       computational_types = {
         calculation_method = "DFT_PBE_PAW",
         basis_requirements = "plane_wave_500eV",
         k_point_density = "8000_per_reciprocal_atom",
         convergence_criteria = "production_quality"
       },
       resource_requirements = {
         memory_estimate = "32GB_minimum",
         cpu_time_estimate = "48_hours_max",
         parallel_efficiency = "good_up_to_64_cores"
       }
     }
   
   Multi-Level Type Checking:
     type_system {
       type_hierarchy = {
         material_class = "ionic_conductor",
         structure_type = "NASICON_framework", 
         composition_type = "lithium_containing",
         defect_type = "vacancy_mediated_transport"
       },
       inheritance_rules = [
         "ionic_conductor - requires mobile_ions",
"NASICON_framework - implies 3D_pathway_network",
"lithium_containing - enables Li_ion_battery_application"
       ]
     }
   
   AUTOMATIC TYPE INFERENCE:
   The system can automatically infer types from structural data and validate
   consistency across all components:
   
     type_system {
       auto_inference = {
         enabled = true,
         inference_methods = [
           "coordination_analysis", "bond_valence_sum", 
           "space_group_analysis", "electronic_structure_prediction"
         ],
         validation_strictness = "moderate",  (* strict, moderate, permissive *)
         error_handling = "warn_and_continue"  (* error, warn_and_continue, silent *)
       }
     }
   
   INTEGRATION WITH OTHER BLOCKS:
   - Basis block: Automatic coordination environment detection
   - Defects block: Validate defect compatibility with host structure
   - Properties block: Ensure property predictions match structural types
   - AI Integration: Type-aware machine learning model selection
   ============================================================================ *)
TypeSystem ::= "type_system" "{" ( StructuralTypes | ChemicalTypes | ComputationalTypes | AutoInference )
              ( "," TypeSystemProperty )* "}" ;

StructuralTypes ::= "structural_types" "=" "{" ( StructuralType )+ "}" ","
                   "compatibility_rules" "=" FeatureList ;

ChemicalTypes ::= "chemical_types" "=" "{" ( ChemicalType )+ "}" ","
                 "validation_rules" "=" FeatureList ;

ComputationalTypes ::= "computational_types" "=" "{" ( ComputationalType )+ "}" ","
                      "resource_requirements" "=" "{" ( ResourceRequirement )+ "}" ;

AutoInference ::= "auto_inference" "=" "{" "enabled" "=" Bool ","
                 "inference_methods" "=" FeatureList ","
                 "validation_strictness" "=" ( "strict" | "moderate" | "permissive" ) ","
                 "error_handling" "=" ( "error" | "warn_and_continue" | "silent" ) "}" ;

StructuralType ::= QName "=" ( Str | FeatureList ) ";" ;
ChemicalType ::= QName "=" ( Str | FeatureList | "{" ( ChemicalProperty )+ "}" ) ";" ;
ComputationalType ::= QName "=" Str ";" ;
ResourceRequirement ::= QName "=" Str ";" ;
ChemicalProperty ::= QName "=" ( Str | FeatureList | "[" ( Str | Num ) ( "," ( Str | Num ) )* "]" ) ";" ;
TypeSystemProperty ::= QName "=" ( Str | Bool | FeatureList ) ;

/*----------------------------  LATTICE SPECIFICATION -------------------------*/
(* ============================================================================
   LATTICE DEFINITION WITH BRAVAIS & VECTOR FORMATS:
   
   The lattice block defines the fundamental geometric framework for the
   structure. Supports both traditional Bravais parameter specification
   and direct lattice vector input for maximum flexibility.
   
   BRAVAIS PARAMETER FORMAT:
   Standard crystallographic approach using lattice constants and angles.
   Automatically validates geometric constraints for each lattice system:
   
   - cubic: a=b=c, α=β=γ=90°
   - tetragonal: a=b≠c, α=β=γ=90°
   - orthorhombic: a≠b≠c, α=β=γ=90°
   - hexagonal: a=b≠c, α=β=90°, γ=120°
   - rhombohedral: a=b=c, α=β=γ≠90°
   - monoclinic: a≠b≠c, α=γ=90°≠β
   - triclinic: a≠b≠c, α≠β≠γ
   
   LATTICE VECTOR FORMAT:
   Direct specification of lattice vectors enables non-standard cells,
   strained structures, and interface modeling:
   
   vectors = (
     (5.431, 0.0, 0.0),      (* a vector *)
     (0.0, 5.431, 0.0),      (* b vector *)
     (0.0, 0.0, 5.431)       (* c vector *)
   )
   
   ADVANCED EXAMPLES:
   
   Strained Silicon (Biaxial Stress):
     lattice {
       description = "Silicon under 2% biaxial tensile strain",
       vectors = (
         (5.539, 0.0, 0.0),    (* 2% expansion in x *)
         (0.0, 5.539, 0.0),    (* 2% expansion in y *)
         (0.0, 0.0, 5.217)     (* Poisson contraction in z *)
       )
     }
   
   Graphene on Substrate (Moiré Pattern):
     lattice {
       description = "Twisted bilayer graphene, 1.1° twist",
       vectors = (
         (12.856, 0.0, 0.0),
         (-6.428, 11.134, 0.0),
         (0.0, 0.0, 20.0)      (* Large c for layer separation *)
       )
     }
   
   Interface Supercell:
     lattice {
       description = "Si/SiO2 interface, 2x2 Si on 1x1 SiO2",
       vectors = (
         (10.862, 0.0, 0.0),
         (0.0, 10.862, 0.0),
         (0.0, 0.0, 25.0)      (* Include vacuum region *)
       )
     }
   
   VALIDATION & ERROR HANDLING:
   - Geometric constraint validation for Bravais parameters
   - Vector linear independence checking
   - Positive volume verification
   - Physically reasonable lattice parameter ranges
   - Automatic detection of special symmetries in vector format
   ============================================================================ *)
Lattice ::= "lattice" "{" "description"? "=" Str "," ( Bravais | Vectors ) "}" ;
Bravais ::= "type" "=" LatT "," "a" "=" Len "," "b" "=" Len "," "c" "=" Len ","
           "alpha" "=" Ang "," "beta" "=" Ang "," "gamma" "=" Ang ;
Vectors ::= "vectors" "=" "(" Vec3 "," Vec3 "," Vec3 ")" ; (* Lattice vectors defining fractional coordinate basis *)

/*----------------------------  SYMMETRY OPERATIONS -------------------------*/
(* ============================================================================
   CRYSTALLOGRAPHIC SYMMETRY WITH ADVANCED FEATURES:
   
   The symmetry block captures the complete symmetry description including
   space groups, magnetic ordering, and superspace modulations. Essential
   for determining equivalent atomic positions and physical properties.
   
   SPACE GROUP SPECIFICATION:
   - Integer: International Tables number (1-230)
   - String: Hermann-Mauguin symbol ("P21/c", "Fm-3m", etc.)
   - Origin choice: Important for centrosymmetric groups
   
   MAGNETIC SYMMETRY:
   Extends crystallographic symmetry to include time-reversal and magnetic
   ordering. Uses Shubnikov group notation for magnetic space groups.
   
   SUPERSPACE STRUCTURES:
   For incommensurate and modulated structures requiring additional
   dimensions beyond the basic 3D lattice:
   - k-vectors: Modulation wave vectors in reciprocal space
   - t_phase: Time phase for temporal modulations
   
   PRACTICAL EXAMPLES:
   
   Standard Crystal (Silicon):
     symmetry {
       description = "Diamond cubic structure",
       space_group = 227,        (* Fd-3m *)
       origin_choice = 2         (* Standard setting *)
     }
   
   Magnetic Material (Magnetite):
     symmetry {
       description = "Inverse spinel with magnetic ordering",
       space_group = "Fd-3m",
       magnetic_group = "Fd'-3m'",  (* Shubnikov notation *)
       origin_choice = 1
     }
   
   Modulated Structure (Incommensurate):
     symmetry {
       description = "Charge density wave modulation",
       space_group = 12,            (* C2/m *)
       superspace = {
         k_vectors = ((0.3, 0.0, 0.5)),  (* Incommensurate modulation *)
         t_phase = 0.0
       }
     }
   
   Complex Superspace (Multiple Modulations):
     symmetry {
       description = "Multiple incommensurate modulations",
       space_group = "P4/mmm",
       superspace = {
         k_vectors = (
           (0.3, 0.3, 0.0),      (* First modulation *)
           (0.1, -0.1, 0.5)      (* Second modulation *)
         ),
         t_phase = 0.25
       }
     }
   
   VALIDATION FEATURES:
   - Space group number/symbol consistency checking
   - Origin choice validation for relevant space groups
   - Magnetic group compatibility with crystal structure
   - k-vector rationality testing for superspace
   - Automatic symmetry detection from atomic positions
   ============================================================================ *)
Symmetry ::= "symmetry" "{" "description"? "=" Str "," "space_group" "=" SG ","
             "origin_choice" "=" Int "," "magnetic_group"? "=" Str "," "superspace"? "=" Superspace "}" ;
Superspace ::= "{" "k_vectors" "=" "(" Vec3F ( "," Vec3F )* ")" "," (* k-vectors in fractional reciprocal coordinates *)
               "t_phase" "=" Num "}" ;

/*----------------------------  ATOMIC BASIS -------------------------*/
(* ============================================================================
   ATOMIC BASIS WITH COMPREHENSIVE SITE SPECIFICATION:
   
   The basis block defines all unique atomic sites in the unit cell with
   complete crystallographic and physical information. Each site supports
   multiple species for disorder modeling and extensive metadata.
   
   SITE SPECIFICATION COMPONENTS:
   - Wyckoff position: Crystallographic site symmetry designation
   - Position: 3D coordinates in specified frame (fractional/cartesian)
   - Species: Chemical composition with occupancy, isotopes, charges
   - Magnetic moments: Vector quantities with explicit frame specification
   - Displacement parameters: Thermal motion (isotropic/anisotropic)
   - Constraints: Refinement and optimization constraints
   
   COORDINATE FRAME HANDLING:
   AtomForge provides explicit frame management to eliminate common errors:
   - fractional: Coordinates in lattice vector basis [0,1]
   - cartesian: Coordinates in Ångström or specified length units
   - Automatic conversion between frames when needed
   - Per-property frame specification for magnetic moments and fields
   
   SPECIES DISORDER MODELING:
   Multiple species per site enable realistic disorder representation:
   - Substitutional disorder: Mixed occupancy on single sites
   - Vacancy modeling: Fractional occupancy < 1.0
   - Isotope specification: Important for neutron scattering
   - Charge states: Essential for electronic structure calculations
   
   COMPREHENSIVE EXAMPLES:
   
   Simple Site (Pure Silicon):
     site "Si1" {
       description = "Tetrahedral silicon in diamond structure",
       wyckoff = "8a",
       position = (0.125, 0.125, 0.125),
       frame = fractional,
       species = (
         { element = "Si", occupancy = 1.0, isotope = 28 }
       ),
       label = "Si_tetrahedral"
     }
   
   Disordered Alloy Site:
     site "Metal1" {
       description = "Mixed Fe/Ni site in steel alloy",
       wyckoff = "4a",
       position = (0.0, 0.0, 0.0),
       frame = fractional,
       species = (
         { element = "Fe", occupancy = 0.7, charge = 0.0, valence = 2 },
         { element = "Ni", occupancy = 0.3, charge = 0.0, valence = 2 }
       ),
       adp_iso = 0.008,  (* Slightly higher thermal motion due to disorder *)
       label = "FeNi_alloy"
     }
   
   Magnetic Site with Anisotropic Displacement:
     site "Fe_oct" {
       description = "Octahedral Fe3+ in magnetite",
       wyckoff = "16d",
       position = (5.25, 5.25, 5.25),
       frame = cartesian,
       species = (
         { element = "Fe", occupancy = 1.0, charge = 3.0, valence = 3 }
       ),
       moment = (0.0, 0.0, 4.2) cartesian "µB",  (* Spin-only moment *)
       adp_aniso = {
         U11 = 0.006, U22 = 0.006, U33 = 0.008,  (* Slightly anisotropic *)
         U12 = 0.001, U13 = 0.000, U23 = 0.000
       },
       constraint = "Fe_octahedral_group",
       label = "Fe3_octahedral"
     }
   
   Partially Occupied Site (Li-ion Battery):
     site "Li_inter" {
       description = "Interstitial Li site for ion transport",
       wyckoff = "8c",
       position = (0.375, 0.375, 0.375),
       frame = fractional,
       species = (
         { element = "Li", occupancy = 0.85, charge = 1.0 }  (* 15% vacancies *)
       ),
       adp_iso = 0.025,  (* High mobility, large displacement *)
       label = "Li_mobile"
     }
   
   ADVANCED DISPLACEMENT PARAMETERS:
   
   Anisotropic Thermal Motion:
     adp_aniso = {
       U11 = 0.005, U22 = 0.005, U33 = 0.012,  (* Larger motion along c *)
       U12 = 0.001, U13 = 0.000, U23 = 0.000   (* Small correlations *)
     }
   
   Alternative Array Format:
     adp_aniso = [0.005, 0.005, 0.012, 0.000, 0.000, 0.001]  (* U11,U22,U33,U23,U13,U12 *)
   
   VALIDATION & ERROR HANDLING:
   - Occupancy sum validation per site (should sum to ≤ 1.0)
   - Element symbol validation against periodic table
   - Coordinate range checking for fractional coordinates [0,1]
   - Displacement parameter positive definiteness
   - Magnetic moment magnitude reasonableness checks
   - Wyckoff position compatibility with space group
   ============================================================================ *)
Basis ::= "basis" "{" "description"? "=" Str "," Site ( "," Site )* "}" ;
Site  ::= "site" Id "{" "description"? "=" Str "," "wyckoff" "=" Wyk "," "position" "=" Vec3F ","
          "frame" "=" Frame "," "species" "=" "(" Species ( "," Species )* ")" ","
          "moment"? "=" Vec3 Frame Str "," (* Magnetic moment vector with explicit frame and unit *)
          "constraint"? "=" Str ","
          "adp_iso"? "=" Disp "," "adp_aniso"? "=" ADP "," "label"? "=" Str "}" ;
Species ::= "{" "element" "=" Elem "," "occupancy" "=" Num ","
              "isotope"? "=" Int "," "charge"? "=" Num "," "valence"? "=" Num "}" ; (* Extended metadata *)
ADP ::= "[" Num "," Num "," Num "," Num "," Num "," Num "]" (* U11, U22, U33, U23, U13, U12 in angstrom^2 *)
     | "{" "U11" "=" Num "," "U22" "=" Num "," "U33" "=" Num "," "U23" "=" Num "," "U13" "=" Num "," "U12" "=" Num "}" ; (* in angstrom^2 *)

/*----------------------------  DEFECT MODELING -------------------------*/
(* ============================================================================
   DEFECT SPECIFICATION FOR REALISTIC MATERIALS:
   
   Real materials contain defects that dramatically affect properties. The
   defects block enables statistical modeling of point defects, essential
   for realistic materials simulations and property predictions.
   
   DEFECT TYPES:
   - vacancy: Missing atom from normal lattice site
   - interstitial: Extra atom in non-lattice position
   - substitution: Wrong atom type on lattice site
   
   STATISTICAL MODELING:
   Each defect has an associated probability representing:
   - Equilibrium concentration at specified temperature
   - Experimentally measured defect density
   - Processing-induced defect population
   
   PRACTICAL EXAMPLES:
   
   Oxygen Vacancies in Metal Oxide:
     defects {
       {
         site_ref = "O_bridge",
         type = "vacancy",
         prob = 0.02  (* 2% oxygen vacancy concentration *)
       },
       {
         site_ref = "O_bridge", 
         type = "substitution",
         prob = 0.001,
         species = { element = "N", occupancy = 1.0 }  (* Nitrogen doping *)
       }
     }
   
   Li-ion Battery Cathode Delithiation:
     defects {
       {
         site_ref = "Li1",
         type = "vacancy", 
         prob = 0.5   (* 50% delithiated state *)
       },
       {
         site_ref = "Li2",
         type = "vacancy",
         prob = 0.3   (* Preferential Li removal from Li1 sites *)
       }
     }
   
   Semiconductor Doping:
     defects {
       {
         site_ref = "Si1",
         type = "substitution",
         prob = 1e-6,  (* 1 ppm phosphorus doping *)
         species = { element = "P", occupancy = 1.0, charge = 1.0 }
       }
     }
   
   Radiation Damage:
     defects {
       {
         site_ref = "U_metal",
         type = "vacancy",
         prob = 0.001  (* Fission-induced vacancies *)
       },
       {
         site_ref = "interstitial_1",
         type = "interstitial",
         prob = 0.0005,
         species = { element = "U", occupancy = 1.0 }  (* Displaced atoms *)
       }
     }
   
   USE CASES:
   - Electronic structure calculations with realistic defect concentrations
   - Ionic conductivity modeling in solid electrolytes
   - Mechanical property degradation due to radiation damage
   - Optical properties modification by defect states
   - Catalytic activity enhancement through controlled defects
   
   INTEGRATION WITH SIMULATIONS:
   - Monte Carlo sampling based on defect probabilities
   - Cluster expansion models for defect interactions
   - Phase diagram calculation including defect formation energies
   - Transport property calculation with defect scattering
   ============================================================================ *)
Defects ::= "defects" "{" DefEntry ( "," DefEntry )* "}" ;
DefEntry ::= "{" "site_ref" "=" Id ","
             "type" "=" ( "vacancy" | "interstitial" | "substitution" ) ","
             "prob" "=" Num ( "," "species" "=" Species )? "}" ;

/*----------------------------  TRANSFORMATIONS & SUPERCELLS -------------------------*/
(* ============================================================================
   REVOLUTIONARY PATCHING MECHANISM & STRUCTURAL TRANSFORMATIONS:
   
   AtomForge's patching system represents a breakthrough in materials structure
   manipulation, enabling version control, systematic modifications, and
   computational workflow integration at the language level.
   
   TRANSFORMATION OPERATIONS:
   The tile block provides supercell generation and geometric transformations:
   - repeat: Integer scaling in each lattice direction
   - origin_shift: Translation of the origin in fractional coordinates
   - transforms: Sequence of geometric operations (mirrors, rotations, translations)
   
   SUPERCELL EXAMPLES:
   
   Simple Supercell (2x2x1):
     tile {
       repeat = (2, 2, 1),  (* Double a and b lattice parameters *)
       origin_shift = (0.0, 0.0, 0.0)  (* No origin translation *)
     }
   
   Surface Slab Construction:
     tile {
       repeat = (1, 1, 5),  (* Extend along c-axis *)
       origin_shift = (0.0, 0.0, 0.1),  (* Shift to create surface *)
       transforms = (
         translate((0.0, 0.0, 10.0) cartesian),  (* Add vacuum layer *)
         mirror(z)  (* Create symmetric slab *)
       )
     }
   
   Strained Interface:
     tile {
       repeat = (3, 3, 1),  (* Commensurate interface *)
       transforms = (
         matrix4 [  (* Biaxial strain transformation *)
           (1.02, 0.0, 0.0, 0.0),
           (0.0, 1.02, 0.0, 0.0), 
           (0.0, 0.0, 0.98, 0.0),
           (0.0, 0.0, 0.0, 1.0)
         ]
       )
     }
   
   GEOMETRIC TRANSFORMATIONS:
   
   Mirror Operations:
     mirror(x)  (* Mirror across yz-plane *)
     mirror(y)  (* Mirror across xz-plane *)
     mirror(z)  (* Mirror across xy-plane *)
   
   Rotation Operations:
     rotate(z, 90 degree)   (* 90° rotation around z-axis *)
     rotate(x, 45 degree)   (* 45° rotation around x-axis *)
   
   Translation Operations:
     translate((1.0, 0.0, 0.0) cartesian)    (* 1 Å along x *)
     translate((0.5, 0.5, 0.0) fractional)   (* Half unit cell shift *)
   
   Matrix Transformations:
     matrix4 [  (* General 4x4 homogeneous transformation *)
       (a11, a12, a13, tx),
       (a21, a22, a23, ty),
       (a31, a32, a33, tz),
       (0.0, 0.0, 0.0, 1.0)
     ]
   
   COMPLEX TRANSFORMATION SEQUENCES:
   
   Twisted Bilayer Construction:
     transforms = (
       translate((0.0, 0.0, 3.4) cartesian),     (* Layer separation *)
       rotate(z, 1.1 degree),                    (* Magic angle twist *)
       translate((1.42, 0.0, 0.0) cartesian)    (* Registry adjustment *)
     )
   
   Grain Boundary Creation:
     transforms = (
       mirror(x),                                (* Create symmetric boundary *)
       rotate(y, 5.0 degree),                    (* Tilt grain boundary *)
       translate((0.0, 0.0, 0.1) fractional)    (* Separate grains *)
     )
   
   USE CASES:
   - High-throughput screening with systematic structural variations
   - Interface modeling for heterostructures
   - Defect engineering through controlled transformations
   - Strain engineering for property tuning
   - Surface and grain boundary construction
   ============================================================================ *)
Tile ::= "tile" "{" "repeat" "=" Vec3I "," "origin_shift"? "=" Vec3F "," (* Origin shift in fractional coordinates *)
         "transforms"? "=" "(" TSeq ( "," TSeq )* ")" "}" ; (* List of individual transform operations *)
TSeq ::= TOp | "(" TSeq ")" ; (* A single transform operation, possibly parenthesized for clarity *)
TOp  ::= Mirror | Rotate | Translate | Mat4 ;
Mirror    ::= "mirror" "(" Axis ")" ; (* Mirror plane normal to the axis, through origin *)
Rotate    ::= "rotate" "(" Axis "," Ang ")" ; (* Rotation around an axis, through origin *)
Translate ::= "translate" "(" Vec3 Frame ")" ; (* Translation vector with explicit frame *)
Mat4      ::= "matrix4" "[" "(" Num "," Num "," Num "," Num ")" "," (* Homogeneous transformation matrix *)
                          "(" Num "," Num "," Num "," Num ")" ","
                          "(" Num "," Num "," Num "," Num ")" ","
                          "(" Num "," Num "," Num "," Num ")" "]" ;

/*----------------------------  CHEMICAL BONDING -------------------------*/
(* ============================================================================
   EXPLICIT BOND SPECIFICATION:
   
   While AtomForge automatically derives connectivity from atomic positions
   and standard bonding radii, explicit bond specification enables:
   - Non-standard coordination environments
   - Constraint specification for geometry optimization
   - Integration with force field parameters
   - Chemical insight documentation
   
   BOND LENGTH SPECIFICATION:
   Each bond is defined between two site identifiers with an explicit length.
   The length serves multiple purposes:
   - Target constraint for geometry optimization
   - Validation against computed distances
   - Documentation of expected coordination
   
   PRACTICAL EXAMPLES:
   
   Coordination Complex:
     bonds {
       ("Cu_center", "N1") = 2.05 angstrom,  (* Cu-N coordination *)
       ("Cu_center", "N2") = 2.05 angstrom,
       ("Cu_center", "O1") = 1.98 angstrom,  (* Cu-O coordination *)
       ("Cu_center", "O2") = 1.98 angstrom
     }
   
   Hydrogen Bonding Network:
     bonds {
       ("O_donor", "H_bridge") = 0.97 angstrom,   (* Covalent O-H *)
       ("H_bridge", "O_acceptor") = 1.85 angstrom (* Hydrogen bond *)
     }
   
   Strained Covalent Network:
     bonds {
       ("Si1", "Si2") = 2.45 angstrom,  (* Longer than bulk Si-Si *)
       ("Si2", "Si3") = 2.31 angstrom,  (* Compressed Si-Si *)
       ("Si3", "O1") = 1.62 angstrom    (* Si-O bridge *)
     }
   
   USE CASES:
   - Molecular dynamics force field parameter assignment
   - Geometry optimization constraint specification
   - Chemical validation of computed structures
   - Integration with quantum chemical calculations
   - Documentation of unusual coordination environments
   ============================================================================ *)
Bonds ::= "bonds" "{" Bond ( "," Bond )* "}" ;
Bond  ::= "(" Id "," Id ")" "=" Len ; (* Bond length between two sites *)

/*----------------------------  EMERGING MATERIALS FEATURES -------------------------*/
(* ============================================================================
   EMERGING MATERIALS SUPPORT FOR NEXT-GENERATION SYSTEMS:
   
   AtomForge explicitly supports cutting-edge materials classes that are
   driving the next generation of technological breakthroughs. This block
   addresses the specific needs of 2D materials, topological systems,
   metamaterials, and quantum materials.
   
   2D MATERIALS:
   Specialized support for layered systems, van der Waals heterostructures,
   and interfacial phenomena in two-dimensional materials:
   - Layer stacking sequences and twist angles
   - Interlayer coupling and moiré patterns
   - Edge terminations and grain boundaries
   
   TOPOLOGICAL MATERIALS:
   Features for materials with non-trivial band topology:
   - Band inversion specifications
   - Surface state characterization
   - Bulk-boundary correspondence
   - Z2 topological invariants
   
   METAMATERIALS:
   Support for artificially structured materials:
   - Periodic unit cell arrangements
   - Effective medium properties
   - Resonance frequencies and bandgaps
   - Chirality and optical activity
   
   QUANTUM MATERIALS:
   Advanced quantum phenomena in condensed matter:
   - Quantum spin liquid states
   - Superconducting gap structures
   - Many-body correlations
   - Entanglement patterns
   
   PRACTICAL EXAMPLES:
   
   Twisted Bilayer Graphene:
     emerging_materials {
       type = "2D_heterostructure",
       layer_stack = {
         layers = [
           { material = "graphene", twist_angle = 1.05 degree },
           { material = "graphene", twist_angle = 0.0 degree }
         ],
         interlayer_distance = 3.35 angstrom,
         coupling_strength = "weak_vdw"
       },
       moire_pattern = {
         period = 13.4 nm,
         symmetry = "D6"
       }
     }
   
   Topological Insulator:
     emerging_materials {
       type = "topological_insulator",
       topology = {
         classification = "3D_strong_TI",
         z2_invariant = "(1;000)",
         surface_states = "dirac_cone",
         bulk_gap = 0.3 eV
       },
       spin_orbit = {
         strength = "strong",
         texture = "helical"
       }
     }
   
   Acoustic Metamaterial:
     emerging_materials {
       type = "metamaterial",
       metamaterial_type = "acoustic",
       unit_cell_period = (2.0, 2.0, 2.0) angstrom,
       effective_properties = {
         bulk_modulus = -150 GPa,  (* Negative bulk modulus *)
         density = 1200 "kg/m3",
         sound_velocity = 343 "m/s"
       },
       resonance = {
         frequency = 1500 Hz,
         quality_factor = 150
       }
     }
   
   Quantum Spin Liquid:
     emerging_materials {
       type = "quantum_material",
       quantum_state = "spin_liquid",
       frustration = {
         type = "geometric",
         lattice = "kagome",
         exchange_ratio = 0.85
       },
       entanglement = {
         pattern = "long_range",
         correlation_length = "infinite"
       }
     }
   
   USE CASES:
   - AI-driven discovery of novel 2D heterostructures
   - High-throughput screening of topological materials
   - Metamaterial design for photonic applications
   - Quantum material property prediction
   - Integration with machine learning models for emergent phenomena
   ============================================================================ *)
EmergingMaterials ::= "emerging_materials" "{" "type" "=" EmergingType ","
                     ( LayerStack | Topology | Metamaterial | QuantumState ) "}" ;

EmergingType ::= "2D_heterostructure" | "topological_insulator" | "topological_semimetal" 
               | "metamaterial" | "quantum_material" | "van_der_waals" | "moire_system" ;

LayerStack ::= "layer_stack" "=" "{" "layers" "=" "[" LayerSpec ( "," LayerSpec )* "]" ","
               "interlayer_distance" "=" Len "," "coupling_strength" "=" Str ( "," LayerProperty )* "}" ;
LayerSpec ::= "{" "material" "=" Str "," "twist_angle" "=" Ang ( "," LayerProperty )* "}" ;

Topology ::= "topology" "=" "{" "classification" "=" Str "," "z2_invariant" "=" Str ","
             "surface_states" "=" Str "," "bulk_gap" "=" Num ( "," TopologyProperty )* "}" ;

Metamaterial ::= "metamaterial_type" "=" Str "," "unit_cell_period" "=" Vec3 ","
                "effective_properties" "=" "{" ( EffectiveProperty )+ "}" ( "," MetamaterialProperty )* ;

QuantumState ::= "quantum_state" "=" Str "," "frustration" "=" "{" FrustrationSpec "}" ","
                "entanglement" "=" "{" EntanglementSpec "}" ( "," QuantumProperty )* ;

LayerProperty ::= QName "=" ( Str | Num | Bool ) ;
TopologyProperty ::= QName "=" ( Str | Num | Bool ) ;
MetamaterialProperty ::= QName "=" ( Str | Num | Bool ) ;
QuantumProperty ::= QName "=" ( Str | Num | Bool ) ;
EffectiveProperty ::= QName "=" ( Num | Str ) ";" ;
FrustrationSpec ::= QName "=" ( Str | Num ) ( "," QName "=" ( Str | Num ) )* ;
EntanglementSpec ::= QName "=" ( Str | Num ) ( "," QName "=" ( Str | Num ) )* ;

/*----------------------------  PHYSICAL PROPERTIES -------------------------*/
(* ============================================================================
   COMPREHENSIVE PROPERTY SPECIFICATION:
   
   AtomForge integrates materials properties directly into structure
   specifications, enabling property-structure relationships and
   machine learning dataset construction.
   
   ELASTIC PROPERTIES:
   Mechanical response tensors in various notations:
   - Full 6x6 elasticity matrix (Voigt notation)
   - Reduced representations for symmetric systems
   - Temperature and pressure dependencies
   
   PHONON PROPERTIES:
   Vibrational characteristics essential for thermal properties:
   - Phonon dispersion on specified q-point grids
   - Zone-center frequencies for Raman/IR spectroscopy
   - Thermodynamic properties derivation
   
   ELECTRONIC PROPERTIES:
   Quantum mechanical characteristics:
   - Band gaps and electronic structure
   - Density of states information
   - Transport properties
   
   PROPERTY EXAMPLES:
   
   Elastic Constants (Silicon):
     elastic {
       C_ijkl = [  (* Voigt notation: C11, C12, C44 for cubic *)
         165.7,  (* C11: compression modulus *)
         63.9,   (* C12: off-diagonal *)
         79.6    (* C44: shear modulus *)
       ]
     }
   
   Phonon Dispersion (High-Symmetry Points):
     phonon {
       q_grid = (8, 8, 8),  (* 8x8x8 Monkhorst-Pack grid *)
       frequencies = [
         0.0, 0.0, 0.0,     (* Acoustic modes at Γ *)
         13.8, 13.8, 16.4   (* Optical modes at Γ, in THz *)
       ]
     }
   
   Custom Properties (Battery Material):
     properties {
       band_gap = 1.8,                    (* eV *)
       ionic_conductivity = 1e-6,         (* S/cm *)
       voltage_vs_Li = 3.45,              (* V *)
       specific_capacity = 170,           (* mAh/g *)
       thermal_stability = 573,           (* K *)
       cost_per_kg = 12.5                 (* USD/kg *)
     }
   
   Temperature-Dependent Properties:
     properties {
       thermal_expansion = {
         "300K": 2.6e-6,  (* /K *)
         "500K": 3.1e-6,
         "800K": 3.8e-6
       },
       resistivity = {
         "77K": 1e-8,     (* Ω⋅m *)
         "300K": 2.3e-8,
         "500K": 4.1e-8
       }
     }
   
   INTEGRATION WITH ML PIPELINES:
   - Standardized property names for machine learning
   - Automatic feature extraction from structure-property pairs
   - Uncertainty quantification for experimental properties
   - Multi-fidelity data integration (DFT, experiment, ML predictions)
   ============================================================================ *)
Elastic ::= "elastic" "{" "C_ijkl" "=" "[" Num ( "," Num )* "]" "}" ; (* Elastic constants (e.g., Voigt notation) *)
Phonon  ::= "phonon" "{" "q_grid" "=" Vec3I ","
            "frequencies" "=" "[" Num ( "," Num )* "]" "}" ;

/*----------------------------  DENSITY MAPS & VOLUMETRIC DATA -------------------------*/
(* ============================================================================
   VOLUMETRIC DATA REPRESENTATION:
   
   Many materials properties are best represented as 3D scalar fields:
   - Electron density from quantum calculations
   - Electrostatic potential maps
   - Magnetic field distributions
   - Probability density for ionic motion
   
   DATA FORMATS:
   - Inline Base64: Compact embedding for small datasets
   - External files: Efficient storage for large volumetric data
   - Grid specification: Regular 3D grids in lattice coordinates
   
   COMPRESSION & STORAGE:
   - Base64 encoding for binary data
   - Support for compressed formats (HDF5, NetCDF)
   - Metadata preservation for data provenance
   
   PRACTICAL EXAMPLES:
   
   Electron Density (Small System):
     density_map {
       grid = (32, 32, 32),  (* 32^3 grid points *)
       format = "float32_little_endian",
       data = "SGVsbG8gV29ybGQ="  (* Base64 encoded density *)
     }
   
   Large Electrostatic Potential:
     density_map {
       grid = (128, 128, 128),  (* High resolution *)
       format = "hdf5_compressed",
       data_file = "/path/to/electrostatic_potential.h5"
     }
   
   Ion Migration Pathway:
     density_map {
       grid = (64, 64, 64),
       format = "probability_density",
       data_file = "li_migration_probability.nc",
       description = "Li+ migration probability from AIMD"
     }
   
   USE CASES:
   - Visualization of electronic structure
   - Analysis of chemical bonding
   - Ion transport pathway identification
   - Defect state localization
   - Integration with machine learning models
   ============================================================================ *)
Density ::= "density_map" "{" "grid" "=" Vec3I "," "format" "=" Str ","
            ( "data" "=" Base64 | "data_file" "=" Str ) ( "," "description" "=" Str )? "}" ; (* Inline Base64 data or path to data file *)
Base64Quad ::= Base64Char Base64Char Base64Char Base64Char ;
Base64Pad2  ::= Base64Char Base64Char "=" "=" ;
Base64Pad   ::= Base64Char Base64Char Base64Char "=" ;
Base64     ::= ( Base64Quad )* ( Base64Pad2 | Base64Pad | Base64Quad ) ; (* Standard Base64; padding characters ('=') only at the very end. *)
Base64Char ::= "A".."Z" | "a".."z" | "0".."9" | "+" | "/" ;

/*----------------------------  ENVIRONMENTAL CONDITIONS -------------------------*/
(* ============================================================================
   ENVIRONMENTAL COUPLING & EXTERNAL FIELDS:
   
   Real materials operate under specific environmental conditions that
   dramatically affect their properties. AtomForge enables specification
   of external conditions for realistic modeling.
   
   THERMODYNAMIC CONDITIONS:
   - Temperature: Thermal energy and phonon populations
   - Pressure: Mechanical stress and structural compression
   
   ELECTROMAGNETIC FIELDS:
   - Electric fields: Polarization and ionic migration
   - Magnetic fields: Spin alignment and magnetoresistance
   - Field gradients: Quadrupole interactions and spectroscopy
   
   FIELD SPECIFICATION:
   All vector fields support explicit frame specification:
   - cartesian: Laboratory fixed coordinates
   - fractional: Crystal-relative coordinates (rare for fields)
   - Units: Explicit dimensional specification
   
   PRACTICAL EXAMPLES:
   
   Battery Operating Conditions:
     environment {
       temperature = 298 K,                    (* Room temperature *)
       pressure = 1 bar,                      (* Atmospheric pressure *)
       e_field = (0.0, 0.0, 1e6) cartesian "V/m"  (* Applied electric field *)
     }
   
   High-Pressure Experiment:
     environment {
       temperature = 2000 K,                  (* High temperature *)
       pressure = 50 GPa,                     (* Extreme pressure *)
       b_field = (0.0, 0.0, 10.0) cartesian "T"  (* Strong magnetic field *)
     }
   
   NMR Spectroscopy Conditions:
     environment {
       temperature = 77 K,                    (* Liquid nitrogen *)
       b_field = (0.0, 0.0, 14.1) cartesian "T",  (* 600 MHz spectrometer *)
       e_grad = [                             (* Electric field gradient tensor *)
         (1.2e6, 0.0, 0.0),
         (0.0, -0.6e6, 0.0),
         (0.0, 0.0, -0.6e6)
       ] cartesian "V/m2"
     }
   
   Electrochemical Cell:
     environment {
       temperature = 333 K,                   (* Elevated temperature *)
       e_field = (0.0, 0.0, 5e5) cartesian "V/m",  (* Applied voltage *)
       electrolyte_concentration = 1.0,      (* mol/L *)
       ph = 7.0                              (* Neutral pH *)
     }
   
   USE CASES:
   - Molecular dynamics under realistic conditions
   - Electronic structure with external perturbations
   - Phase diagram calculation as function of conditions
   - Spectroscopic property prediction
   - Device modeling under operating conditions
   ============================================================================ *)
Environment ::= "environment" "{" "temperature"? "=" Temp "," "pressure"? "=" Pres ","
                "e_field"? "=" Vec3 Frame? Str "," (* Electric field vector; Frame optional, Cartesian often implied if omitted. *)
                "e_grad"? "=" Mat3 Frame? FieldGradU "," (* Electric field gradient tensor; Frame for Mat3 optional, Cartesian often implied if omitted. *)
                "b_field"? "=" Vec3 Frame? Str "}" ; (* Magnetic field vector; Frame optional, Cartesian often implied if omitted. *)
Mat3        ::= "[" "(" Num "," Num "," Num ")" "," "(" Num "," Num "," Num ")" "," "(" Num "," Num "," Num ")" "]" ; (* 3x3 Matrix *)
FieldGradU  ::= "V/m2" | "T/m" ;

/*----------------------------  AI-NATIVE INTEGRATION -------------------------*/
(* ============================================================================
   AI-NATIVE CONSTRUCTS FOR MACHINE LEARNING WORKFLOWS:
   
   AtomForge provides first-class support for AI and machine learning
   integration, making it the ideal format for next-generation materials
   discovery pipelines. These constructs enable seamless integration with
   graph neural networks, generative models, and automated discovery systems.
   
   GRAPH NEURAL NETWORK SUPPORT:
   Native constructs for representing materials as graphs with node and edge
   features for direct consumption by GNN architectures:
   - Atomic features: Element type, coordination, oxidation state
   - Bond features: Distance, bond order, electronic character
   - Graph topology: Connectivity matrices, neighbor lists
   
   GENERATIVE MODEL INTEGRATION:
   Support for AI-driven structure generation and optimization:
   - Latent space embeddings for structure representation
   - Constraint satisfaction for generated structures
   - Probabilistic sampling from learned distributions
   
   AUTOMATED DISCOVERY WORKFLOWS:
   Integration with high-throughput screening and active learning:
   - Property prediction targets and uncertainties
   - Acquisition functions for next-structure selection
   - Multi-objective optimization criteria
   
   PRACTICAL EXAMPLES:
   
   Graph Neural Network Features:
     ai_integration {
       graph_representation = {
         node_features = [
           "atomic_number", "electronegativity", "covalent_radius",
           "oxidation_state", "coordination_number"
         ],
         edge_features = [
           "bond_distance", "bond_order", "electronic_overlap"
         ],
         global_features = [
           "space_group", "density", "formation_energy"
         ]
       },
       model_target = "band_gap_prediction",
       uncertainty_quantification = true
     }
   
   Generative Model Integration:
     ai_integration {
       generation_model = {
         type = "VAE_crystal",
         latent_dim = 512,
         constraints = [
           "charge_neutrality", "space_group_symmetry", "realistic_bonding"
         ],
         sampling_temperature = 0.8
       },
       optimization_target = {
         property = "ionic_conductivity",
         direction = "maximize",
         constraint = "formation_energy < 0.1 eV/atom"
       }
     }
   
   Active Learning Workflow:
     ai_integration {
       active_learning = {
         acquisition_function = "expected_improvement",
         surrogate_model = "gaussian_process",
         exploration_weight = 0.1,
         batch_size = 10
       },
       prediction_targets = [
         { property = "bulk_modulus", uncertainty = "aleatoric" },
         { property = "band_gap", uncertainty = "epistemic" }
       ]
     }
   
   Multi-Fidelity Learning:
     ai_integration {
       multi_fidelity = {
         low_fidelity = "classical_force_field",
         high_fidelity = "DFT_hybrid_functional",
         correlation_model = "nonlinear_autoregressive",
         cost_ratio = 1000
       },
       transfer_learning = {
         source_domain = "binary_oxides",
         target_domain = "ternary_phosphates",
         adaptation_method = "domain_adversarial"
       }
     }
   
   USE CASES:
   - Direct integration with PyTorch Geometric and DGL frameworks
   - Automated materials discovery with reinforcement learning
   - Uncertainty-aware property prediction
   - Transfer learning across materials classes
   - Multi-objective optimization of materials properties
   - Real-time structure validation during generation
   ============================================================================ *)
AIIntegration ::= "ai_integration" "{" ( GraphRepresentation | GenerationModel | ActiveLearning | MultiFidelity ) 
                 ( "," AIIntegrationProperty )* "}" ;

GraphRepresentation ::= "graph_representation" "=" "{" "node_features" "=" FeatureList ","
                       "edge_features" "=" FeatureList "," "global_features" "=" FeatureList "}" ;

GenerationModel ::= "generation_model" "=" "{" "type" "=" Str "," "latent_dim" "=" Int ","
                   "constraints" "=" FeatureList "," "sampling_temperature" "=" Num "}" ;

ActiveLearning ::= "active_learning" "=" "{" "acquisition_function" "=" Str ","
                  "surrogate_model" "=" Str "," "exploration_weight" "=" Num ","
                  "batch_size" "=" Int "}" ;

MultiFidelity ::= "multi_fidelity" "=" "{" "low_fidelity" "=" Str ","
                  "high_fidelity" "=" Str "," "correlation_model" "=" Str ","
                  "cost_ratio" "=" Num "}" ;

FeatureList ::= "[" Str ( "," Str )* "]" ;
AIIntegrationProperty ::= QName "=" ( Str | Num | Bool | FeatureList ) ;

/*----------------------------  PROCEDURAL GENERATION SYSTEM -------------------------*/
(* ============================================================================
   PROCEDURAL GENERATION INSPIRED BY METAGEN:
   
   Based on MetaGen's successful approach to systematic structure generation,
   AtomForge now includes procedural generation capabilities that enable
   systematic exploration of materials space through parameterized families.
   
   GENERATOR TYPES:
   - Template-based: Generate families from structural templates
   - Parameter-sweep: Systematic exploration of parameter spaces
   - Combinatorial: Systematic combination of structural motifs
   - ML-guided: AI-driven structure generation and optimization
   
   HYBRIDIZATION SYSTEM:
   Following MetaGen's crossover approach, enable genetic-algorithm-like
   combination of parent structures to discover novel materials:
   - Parent selection based on property similarity or complementarity
   - Crossover operations respecting structural constraints
   - Mutation operations for fine-tuning generated structures
   
   PRACTICAL EXAMPLES:
   
   Template-Based Generation:
     procedural_generation {
       generator_type = "template_based",
       template = "perovskite_ABX3",
       parameter_space = {
         A_site = ["La", "Sr", "Ca", "Ba"],
         B_site = ["Ti", "Zr", "Hf", "Sn"],
         X_site = ["O"],
         tolerance_factor = [0.8, 1.1]
       },
       constraints = [
         "charge_neutrality", "ionic_radius_compatibility", "formation_energy < 0.1"
       ]
     }
   
   Parameter Sweep Generation:
     procedural_generation {
       generator_type = "parameter_sweep",
       base_structure = "battery_cathode_layered",
       sweep_parameters = {
         layer_spacing = [2.5, 3.0, 3.5, 4.0],  (* Angstrom *)
         Li_occupancy = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
         transition_metal = ["Co", "Ni", "Mn"]
       },
       generation_mode = "combinatorial"  (* All combinations *)
     }
   
   ML-Guided Generation:
     procedural_generation {
       generator_type = "ml_guided",
       target_properties = {
         ionic_conductivity = "> 1e-3 S/cm",
         formation_energy = "< 0.05 eV/atom",
         band_gap = "> 1.0 eV"
       },
       generation_method = "VAE_latent_sampling",
       population_size = 1000,
       generations = 50
     }
   
   Hybridization System:
     procedural_generation {
       generator_type = "hybridization",
       parent_selection = {
         method = "property_complementarity",
         parent_A = "high_ionic_conductivity_structure",
         parent_B = "high_mechanical_stability_structure"
       },
       crossover_operations = [
         "framework_preservation", "dopant_mixing", "defect_combination"
       ],
       mutation_rate = 0.1,
       fitness_function = "multi_objective_pareto"
     }
   
   INTEGRATION WITH ATOMFORGE ECOSYSTEM:
   - Generated structures automatically include full provenance tracking
   - Compatible with patching system for systematic modifications
   - Integration with AI blocks for automated property prediction
   - Support for high-throughput computational workflows
   
   VALIDATION AND QUALITY CONTROL:
   - Automatic structure validation (charge neutrality, bonding, stability)
   - Property prediction and filtering
   - Similarity checking to avoid duplicates
   - Export to standard formats for external validation
   ============================================================================ *)
ProceduralGeneration ::= "procedural_generation" "{" "generator_type" "=" GeneratorType ","
                        ( TemplateGeneration | ParameterSweep | MLGuided | Hybridization )
                        ( "," GenerationProperty )* "}" ;

GeneratorType ::= "template_based" | "parameter_sweep" | "combinatorial" | "ml_guided" | "hybridization" ;

TemplateGeneration ::= "template" "=" Str "," "parameter_space" "=" "{" ( ParameterSpace )+ "}" "," 
                      "constraints" "=" FeatureList ;

ParameterSweep ::= "base_structure" "=" Str "," "sweep_parameters" "=" "{" ( SweepParameter )+ "}" ","
                  "generation_mode" "=" ( "combinatorial" | "random_sampling" | "adaptive" ) ;

MLGuided ::= "target_properties" "=" "{" ( PropertyTarget )+ "}" "," "generation_method" "=" Str ","
            "population_size" "=" Int "," "generations" "=" Int ;

Hybridization ::= "parent_selection" "=" "{" ParentSelection "}" "," "crossover_operations" "=" FeatureList ","
                 "mutation_rate" "=" Num "," "fitness_function" "=" Str ;

ParameterSpace ::= QName "=" ( FeatureList | "[" Num "," Num "]" ) ";" ;
SweepParameter ::= QName "=" ( FeatureList | "[" Num "," Num "," Num "]" ) ";" ; (* [min, max, step] *)
PropertyTarget ::= QName "=" Str ";" ;
ParentSelection ::= ( "method" "=" Str | QName "=" Str ) ( "," ( "method" "=" Str | QName "=" Str ) )* ;
GenerationProperty ::= QName "=" ( Str | Num | Bool | FeatureList ) ;

/*----------------------------  BENCHMARKING SYSTEM -------------------------*/
(* ============================================================================
   COMPREHENSIVE BENCHMARKING INSPIRED BY METABENCH:
   
   Following MetaGen's systematic approach to VLM evaluation, AtomForge
   provides comprehensive benchmarking capabilities for testing AI systems
   across multiple materials science tasks.
   
   CORE BENCHMARK CATEGORIES:
   
   1. STRUCTURE RECONSTRUCTION:
      - Generate AtomForge specifications from images, descriptions, or partial data
      - Test multi-modal understanding (images + text + property data)
      - Evaluate structural accuracy and chemical validity
   
   2. PROPERTY PREDICTION:
      - Predict materials properties from structural specifications
      - Multi-fidelity prediction (fast screening vs. accurate calculation)
      - Uncertainty quantification and confidence estimation
   
   3. INVERSE DESIGN:
      - Generate structures that satisfy target property requirements
      - Multi-objective optimization scenarios
      - Constraint satisfaction and feasibility checking
   
   4. MATERIALS UNDERSTANDING:
      - Explain structure-property relationships
      - Predict synthesis conditions and processing requirements
      - Identify novel materials classes and design principles
   
   PRACTICAL EXAMPLES:
   
   Structure Reconstruction Benchmark:
     benchmarking {
       benchmark_type = "structure_reconstruction",
       tasks = [
         {
           input_modality = ["images", "xrd_pattern", "composition"],
           target_output = "complete_atomforge_specification",
           difficulty_level = "expert",
           evaluation_metrics = ["structural_accuracy", "chemical_validity", "completeness"]
         }
       ],
       dataset_split = {
         train = 0.7,
         validation = 0.15,
         test = 0.15
       }
     }
   
   Property Prediction Benchmark:
     benchmarking {
       benchmark_type = "property_prediction",
       tasks = [
         {
           input_data = "atomforge_specification",
           target_properties = ["band_gap", "formation_energy", "ionic_conductivity"],
           prediction_fidelity = "DFT_quality",
           uncertainty_quantification = true
         }
       ],
       evaluation_criteria = {
         accuracy_threshold = 0.1,  (* eV for energies *)
         correlation_requirement = 0.9,
         uncertainty_calibration = true
       }
     }
   
   Inverse Design Benchmark:
     benchmarking {
       benchmark_type = "inverse_design",
       tasks = [
         {
           target_properties = {
             band_gap = [1.0, 2.0],  (* eV range *)
             formation_energy = "< -0.1 eV/atom",
             ionic_conductivity = "> 1e-3 S/cm"
           },
           constraints = ["charge_neutrality", "thermodynamic_stability"],
           optimization_type = "multi_objective_pareto"
         }
       ],
       success_criteria = {
         property_satisfaction = "all_targets_met",
         structural_validity = "chemically_reasonable",
         synthesizability_score = "> 0.5"
       }
     }
   
   Multi-Modal Understanding:
     benchmarking {
       benchmark_type = "materials_understanding",
       tasks = [
         {
           input_types = ["structure", "properties", "synthesis_conditions"],
           question_types = ["explain", "predict", "optimize", "compare"],
           complexity_levels = ["undergraduate", "graduate", "expert"],
           domain_coverage = ["batteries", "catalysts", "semiconductors", "superconductors"]
         }
       ]
     }
   
   EVALUATION FRAMEWORK:
   
   Automated Scoring:
     benchmarking {
       evaluation_framework = {
         structural_metrics = [
           "root_mean_square_deviation", "coordination_accuracy", "symmetry_preservation"
         ],
         property_metrics = [
           "mean_absolute_error", "coefficient_determination", "rank_correlation"
         ],
         chemical_validity = [
           "charge_balance", "electronegativity_consistency", "bond_length_reasonableness"
         ],
         ai_specific_metrics = [
           "hallucination_detection", "uncertainty_calibration", "explanation_quality"
         ]
       }
     }
   
   Human Evaluation:
     benchmarking {
       human_evaluation = {
         expert_panels = ["crystallographers", "computational_chemists", "materials_engineers"],
         evaluation_criteria = ["scientific_accuracy", "practical_utility", "novelty"],
         scoring_protocol = "blind_review_panel",
         inter_rater_reliability = "> 0.8"
       }
     }
   
   INTEGRATION WITH AI SYSTEMS:
   - Direct integration with AtomForge AI blocks
   - Support for popular ML frameworks (PyTorch, TensorFlow, JAX)
   - Automated model evaluation pipelines
   - Performance tracking and comparison tools
   ============================================================================ *)
Benchmarking ::= "benchmarking" "{" "benchmark_type" "=" BenchmarkType ","
                "tasks" "=" "[" BenchmarkTask ( "," BenchmarkTask )* "]" 
                ( "," BenchmarkProperty )* "}" ;

BenchmarkType ::= "structure_reconstruction" | "property_prediction" | "inverse_design" 
                | "materials_understanding" | "multi_modal" | "comprehensive" ;

BenchmarkTask ::= "{" ( TaskProperty )+ "}" ;
TaskProperty ::= ( "input_modality" "=" FeatureList
               | "input_data" "=" Str
               | "target_output" "=" Str  
               | "target_properties" "=" ( FeatureList | "{" ( PropertySpec )+ "}" )
               | "difficulty_level" "=" ( "beginner" | "intermediate" | "expert" )
               | "evaluation_metrics" "=" FeatureList
               | "constraints" "=" FeatureList
               | QName "=" ( Str | Num | Bool | FeatureList )
               ) ";" ;

PropertySpec ::= QName "=" ( Str | Num | "[" Num "," Num "]" ) ";" ;
BenchmarkProperty ::= QName "=" ( Str | Num | Bool | FeatureList | "{" ( PropertySpec )+ "}" ) ;

/*----------------------------  EXTENSIBLE PROPERTIES & VALIDATION -------------------------*/
(* ============================================================================
   FLEXIBLE PROPERTY SYSTEM:
   
   The properties block provides unlimited extensibility for domain-specific
   properties while maintaining type safety and dimensional consistency.
   Supports all AtomForge data types including custom units.
   
   PROPERTY VALUE TYPES:
   - Scalars: Numbers with optional units
   - Vectors: 3D quantities with frame specification
   - Arrays: Lists of values for multi-component properties
   - Strings: Categorical or textual properties
   - Booleans: Binary characteristics
   
   VALIDATION SYSTEM:
   Comprehensive validation ensures data quality and consistency:
   - Tolerance: Numerical precision for comparisons
   - Occupancy clamping: Automatic correction of minor occupancy errors
   - Vector unit consistency: Frame and dimensional validation
   - Transform depth limits: Prevents infinite recursion
   - Unit enforcement: Strict dimensional analysis
   
   PROPERTY EXAMPLES:
   
   Materials Science Properties:
     properties {
       hardness = 9.0,                       (* Mohs scale *)
       density = 3.52 "g/cm3",               (* With units *)
       melting_point = 1687 K,               (* Temperature *)
       band_gap = 5.47 "eV",                 (* Energy *)
       refractive_index = [2.417, 2.419],    (* Birefringent crystal *)
       color = "colorless",                  (* Categorical *)
       piezoelectric = true,                 (* Boolean property *)
       elastic_moduli = (320, 180, 42) "GPa" (* Vector with units *)
     }
   
   Electrochemical Properties:
     properties {
       standard_potential = 3.4 "V",         (* vs Li/Li+ *)
       ionic_conductivity = 1e-4 "S/cm",
       electronic_conductivity = 1e-8 "S/cm",
       activation_energy = 0.65 "eV",
       diffusion_coefficient = 1e-12 "cm2/s",
       stability_window = [1.0, 4.5] "V"     (* Electrochemical window *)
     }
   
   Comprehensive Validation:
     validation {
       tolerance = 1e-6,                     (* Numerical precision *)
       occupancy_clamp = true,               (* Auto-correct minor errors *)
       vector_unit_consistent = true,        (* Enforce dimensional consistency *)
       max_transform_depth = 64,             (* Recursion limit *)
       enforce_units = true                  (* Strict unit checking *)
     }
   
   Flexible Validation:
     validation {
       tolerance = 1e-4,                     (* Relaxed precision *)
       occupancy_clamp = false,              (* Report all occupancy errors *)
       vector_unit_consistent = false,       (* Allow mixed units *)
       max_transform_depth = 128,            (* Higher recursion limit *)
       enforce_units = false                 (* Warning-only unit checking *)
     }
   
   INTEGRATION BENEFITS:
   - Machine learning feature extraction from structured properties
   - Automatic validation prevents common data quality issues
   - Extensible system accommodates domain-specific needs
   - Type safety ensures dimensional consistency
   - Standards compliance for materials databases
   ============================================================================ *)
Properties ::= "properties" "{" PEntry ( "," PEntry )* "}" ;
PEntry     ::= QName "=" PVal ;
PVal       ::= Num | Str | "(" Vec3 Frame? ")" | Vec3I | "[" Num ( "," Num )* "]" | Bool
              | Len | Ang | Temp | Pres | Disp ;
              (* Vec3 can have optional frame. Dimensioned types allow explicit units. *)

Validation ::= "validate" "{" "tolerance" "=" Num "," "occupancy_clamp" "=" Bool ","
               "vector_unit_consistent" "=" Bool ","
               "max_transform_depth" "=" Int "," (* default = 64 *)
               "enforce_units" "=" Bool "}" ;

/*----------------------------  COMPLEXITY MANAGEMENT -------------------------*/
(* ============================================================================
   SIMPLIFICATION DIRECTIVES FOR USABILITY:
   
   To address the inherent complexity of comprehensive materials specification,
   AtomForge provides simplification directives that help users manage
   complexity while maintaining scientific rigor.
   
   PROGRESSIVE DISCLOSURE:
   Enable users to start simple and add complexity as needed:
   - Minimal specifications with intelligent defaults
   - Template-based structure generation
   - Incremental complexity addition
   
   CONTEXT-AWARE ASSISTANCE:
   Help users navigate the language based on their use case:
   - Domain-specific templates
   - Validation with helpful suggestions
   - Automatic completion of related fields
   
   PRACTICAL EXAMPLES:
   
   Beginner-Friendly Mode:
     simplification {
       complexity_level = "beginner",
       auto_complete = true,
       suggest_defaults = true,
       hide_advanced_features = [
         "superspace", "environment.e_grad", "ai_integration"
       ],
       template_suggestions = true
     }
   
   Expert Mode:
     simplification {
       complexity_level = "expert",
       auto_complete = false,
       suggest_defaults = false,
       show_all_features = true,
       advanced_validation = true
     }
   
   Domain-Specific Templates:
     simplification {
       domain = "battery_materials",
       templates = [
         "li_ion_cathode", "solid_electrolyte", "anode_material"
       ],
       required_properties = [
         "ionic_conductivity", "voltage_vs_li", "specific_capacity"
       ]
     }
   ============================================================================ *)
Simplification ::= "simplification" "{" "complexity_level" "=" ComplexityLevel ","
                  "auto_complete" "=" Bool "," "suggest_defaults" "=" Bool ","
                  ( SimplificationOption )* "}" ;

ComplexityLevel ::= "beginner" | "intermediate" | "expert" | "domain_specific" ;
SimplificationOption ::= "hide_advanced_features" "=" FeatureList 
                      | "template_suggestions" "=" Bool
                      | "domain" "=" Str
                      | "templates" "=" FeatureList
                      | "required_properties" "=" FeatureList
                      | QName "=" ( Str | Bool | FeatureList ) ;

/*----------------------------  PROVENANCE & DATA LINEAGE -------------------------*/
(* ============================================================================
   COMPREHENSIVE PROVENANCE TRACKING:
   
   Scientific reproducibility requires detailed tracking of data origins,
   computational methods, and processing history. AtomForge embeds provenance
   directly into structure specifications.
   
   PROVENANCE COMPONENTS:
   - Source: Origin of the structural data (experiment, theory, database)
   - Method: Computational or experimental technique used
   - DOI: Digital Object Identifier for published references
   - URL: Web location for additional resources
   
   COMPUTATIONAL PROVENANCE:
   Essential for theoretical calculations and simulations:
   - Software packages and versions
   - Computational parameters and convergence criteria
   - Hardware specifications and computational cost
   - Validation against experimental data
   
   EXPERIMENTAL PROVENANCE:
   Critical for experimental structure determinations:
   - Diffraction technique and instrument details
   - Sample preparation and measurement conditions
   - Data processing software and refinement parameters
   - Quality indicators and reliability metrics
   
   DETAILED EXAMPLES:
   
   DFT Calculation:
     provenance {
       source = "Density Functional Theory Calculation",
       method = "PBE+U functional, U_eff(Co) = 3.32 eV, 500 eV cutoff, 8x8x8 k-points",
       software = "VASP 6.3.0",
       computational_details = "Intel Xeon Gold 6248, 96 cores, 24 hours",
       convergence = "Energy: 1e-6 eV, Forces: 0.01 eV/Å",
       doi = "10.1038/s41567-021-01234-x",
       validation = "Lattice parameters within 2% of experiment"
     }
   
   Neutron Diffraction:
     provenance {
       source = "Powder Neutron Diffraction",
       method = "POWGEN beamline, SNS, λ = 1.333 Å, 300 K",
       instrument = "High-resolution powder diffractometer",
       sample_details = "Polycrystalline powder, 2g sample mass",
       data_processing = "GSAS-II refinement, Rietveld method",
       quality_factors = "Rwp = 3.2%, Rp = 2.1%, χ² = 1.8",
       doi = "10.1107/S1600576721012345",
       measurement_date = "2025-03-15"
     }
   
   Machine Learning Prediction:
     provenance {
       source = "Graph Neural Network Prediction",
       method = "M3GNet universal potential, trained on MPF.2021.2.8",
       model_version = "M3GNet-UP-2022.7.7-PES",
       training_data = "Materials Project database, 146,000 structures",
       accuracy = "Formation energy MAE: 25 meV/atom",
       software = "PyMatGen 2023.5.10, TensorFlow 2.12.0",
       prediction_confidence = 0.92,
       url = "https://github.com/materialsvirtuallab/m3gnet"
     }
   
   Database Export:
     provenance {
       source = "Materials Project Database",
       method = "High-throughput DFT screening",
       database_version = "MPF.2021.2.8",
       entry_id = "mp-149",
       last_updated = "2021-02-08",
       doi = "10.1063/1.4812323",
       url = "https://materialsproject.org/materials/mp-149",
       license = "CC BY 4.0"
     }
   
   AUTOMATED PROVENANCE:
   - Git commit hashes for version control
   - Software environment snapshots (conda, docker)
   - Computational resource usage tracking
   - Automatic citation generation
   - Workflow provenance for complex pipelines
   
   BENEFITS FOR REPRODUCIBILITY:
   - Full traceability of data origins
   - Method validation and comparison
   - Error source identification
   - Citation compliance for publications
   - Quality assessment and confidence levels
   ============================================================================ *)
Provenance ::= "provenance" "{" "source" "=" Str "," "method" "=" Str ","
               "doi" "=" Str "," "url"? "=" Str ( "," ProvenanceExtension )* "}" ;
ProvenanceExtension ::= QName "=" ( Str | Num | Bool ) ;

/*----------------------------  REVOLUTIONARY PATCHING SYSTEM -------------------------*/
(* ============================================================================
   ATOMFORGE PATCHING: REVOLUTIONARY STRUCTURE MODIFICATION SYSTEM:
   
   AtomForge's patching mechanism represents a paradigm shift in materials
   structure manipulation, enabling systematic modifications, version control,
   and computational workflow integration at the language level.
   
   PATH-BASED ADDRESSING:
   The patching system uses hierarchical paths to precisely target any
   component of a structure specification:
   - Dot notation: basis.siteID.label
   - Array indexing: basis.siteID.species[0].occupancy
   - Deep nesting: environment.e_field[2]
   
   OPERATION TYPES:
   
   1. ADD: Insert new structural components
      - New atomic sites with complete specification
      - Additional species to existing sites
      - New property definitions
   
   2. REMOVE: Delete structural components
      - Entire atomic sites
      - Individual species from multi-species sites
      - Specific property fields
   
   3. UPDATE: Modify existing components
      - Atomic positions and coordinates
      - Occupancy values and charges
      - Property values and units
   
   REVOLUTIONARY APPLICATIONS:
   
   Systematic Doping Study:
     patch {
       (* Create a series of Ti-doped structures *)
       update basis.Al1.species[0].occupancy = 0.95,
       add site "Ti_dopant" {
         wyckoff = "4a",
         position = (0.125, 0.125, 0.125),
         frame = fractional,
         species = ({ element = "Ti", occupancy = 0.05, charge = 4.0 }),
         label = "Ti_substitution"
       }
     }
   
   Defect Engineering:
     patch {
       (* Remove Li from specific sites to model delithiation *)
       update basis.Li1.species[0].occupancy = 0.0,  (* Create vacancy *)
       update basis.Li2.species[0].occupancy = 0.5,  (* Partial delithiation *)
       remove basis.Li3,  (* Complete site removal *)
       (* Add compensating electronic structure changes *)
       update properties.band_gap = 2.1  (* Modified electronic structure *)
     }
   
   Interface Construction:
     patch {
       (* Modify surface termination *)
       remove basis.O_surface,  (* Remove surface oxygen *)
       add site "H_termination" {
         wyckoff = "1a",
         position = (0.0, 0.0, 0.95),
         frame = fractional,
         species = ({ element = "H", occupancy = 1.0 }),
         label = "Surface_passivation"
       },
       (* Adjust surface properties *)
       update environment.temperature = 773 K,  (* High-temperature conditions *)
       update properties.surface_energy = 1.2  (* J/m² *)
     }
   
   Strain Engineering:
     patch {
       (* Apply biaxial strain *)
       update lattice.a = 5.540,  (* 2% tensile strain *)
       update lattice.b = 5.540,  (* Maintain symmetry *)
       update lattice.c = 5.217,  (* Poisson contraction *)
       (* Update affected properties *)
       update properties.band_gap = 0.95,  (* Strain-induced modification *)
       update properties.elastic_modulus = 145  (* GPa, modified stiffness *)
     }
   
   Computational Workflow Integration:
     patch {
       (* Update from DFT optimization results *)
       update basis.Fe1.position = (0.0002, 0.0001, 0.0003),  (* Relaxed coordinates *)
       update basis.Fe1.adp_iso = 0.0082,  (* Updated thermal parameters *)
       update lattice.a = 5.4195,  (* Optimized lattice parameter *)
       (* Add computational metadata *)
       update properties.formation_energy = -0.85,  (* eV/atom *)
       update provenance.method = "PBE+U relaxation, converged forces < 0.01 eV/Å"
     }
   
   ADVANCED PATCHING FEATURES:
   
   Conditional Modifications:
     patch {
       (* Apply modifications based on conditions *)
       @if(temperature > 500) update lattice.a = 5.485,  (* Thermal expansion *)
       @if(pressure > 10) update lattice.c = 5.380      (* Pressure compression *)
     }
   
   Parameterized Patches:
     patch {
       (* Use variables for systematic studies *)
       @parameter x_doping = 0.1,
       update basis.Host.species[0].occupancy = (1.0 - x_doping),
       add site "Dopant" {
         species = ({ element = "Ti", occupancy = x_doping })
       }
     }
   
   VALIDATION & ERROR HANDLING:
   - Path validation: Ensures target components exist
   - Type compatibility: Verifies value types match target fields
   - Constraint satisfaction: Maintains physical and chemical validity
   - Dependency tracking: Updates related fields automatically
   - Rollback capability: Undo changes if validation fails
   
   REVOLUTIONARY IMPACT:
   - Version control for materials structures
   - Systematic exploration of chemical space
   - Reproducible computational workflows
   - Collaborative structure development
   - Integration with machine learning pipelines
   - Automated structure generation and optimization
   ============================================================================ *)
PathSegment ::= Ident ( "[" Int "]" )? ; (* e.g., 'name' or 'list[0]' *)
Path       ::= PathSegment ( "." PathSegment )* ; (* e.g., 'basis.siteID.label' or 'basis.siteID.species[0].occupancy' *)
Patch ::= "patch" "{" PatchOp ( "," PatchOp )* "}" ;
PatchOp ::= "add" ( Site | Path "=" PVal ) | (* Adds a new Site to the main Basis collection, or adds value at Path *)
            "remove" Path | (* Removes the element at Path (e.g., a whole Site, a Species in a list, a Site's label field). *)
            "update" Path "=" PVal ; (* Updates the field at Path with PVal. Target field type must be semantically compatible with PVal. *)

/*----------------------------  EXTENSIBLE METADATA -------------------------*/
(* ============================================================================
   USER-DEFINED METADATA SYSTEM:
   
   The meta block provides unlimited extensibility for domain-specific
   metadata, experimental conditions, and computational parameters while
   maintaining type safety and structure.
   
   METADATA APPLICATIONS:
   - Experimental conditions not covered by standard blocks
   - Computational parameters for reproducibility
   - Quality indicators and uncertainty estimates
   - Custom classifications and tags
   - Integration with external databases and workflows
   
   TYPE SYSTEM:
   - Strings: Textual descriptions, identifiers, classifications
   - Numbers: Quantitative measurements, parameters, scores
   - Booleans: Binary characteristics, flags, options
   
   PRACTICAL EXAMPLES:
   
   Experimental Metadata:
     meta {
       sample_id = "BTO_2025_005",
       preparation_method = "solid_state_synthesis",
       annealing_temperature = 1200,  (* Celsius *)
       annealing_time = 12,  (* hours *)
       cooling_rate = 5.0,  (* K/min *)
       atmosphere = "air",
       grain_size_estimate = 2.5,  (* micrometers *)
       phase_purity = 0.98,  (* fraction *)
       synthesis_batch = "batch_07",
       operator = "J.Smith",
       laboratory = "Materials_Synthesis_Lab_B"
     }
   
   Computational Metadata:
     meta {
       calculation_type = "structure_relaxation",
       software_version = "VASP_6.3.0",
       pseudopotential_set = "PBE_PAW",
       energy_cutoff = 500,  (* eV *)
       k_point_density = 8000,  (* per reciprocal atom *)
       electronic_convergence = 1e-6,  (* eV *)
       force_convergence = 0.01,  (* eV/Angstrom *)
       computational_cost = 2400,  (* CPU hours *)
       memory_usage = 128,  (* GB *)
       wall_time = 18.5,  (* hours *)
       queue_system = "SLURM",
       cluster_name = "HPC_Materials"
     }
   
   Quality Assessment:
     meta {
       structure_quality = "high",
       refinement_converged = true,
       residual_factor = 0.032,
       goodness_of_fit = 1.18,
       completeness = 0.987,
       redundancy = 3.2,
       resolution_limit = 0.8,  (* Angstrom *)
       data_collection_temperature = 100,  (* K *)
       crystal_size = [0.2, 0.15, 0.1],  (* mm *)
       diffractometer = "APEX_II",
       radiation_type = "Mo_Ka"
     }
   
   Machine Learning Integration:
     meta {
       dataset_partition = "training",
       cross_validation_fold = 3,
       feature_importance_score = 0.85,
       prediction_confidence = 0.92,
       model_version = "GCN_v2.1",
       training_epochs = 500,
       validation_loss = 0.023,
       overfitting_indicator = false,
       feature_engineering = "automatic",
       normalization_method = "z_score"
     }
   
   Database Integration:
     meta {
       database_id = "ICSD_12345",
       collection_code = "COD_7000001", 
       mp_id = "mp-149",
       oqmd_id = "oqmd-123456",
       export_timestamp = "2025-05-08T14:30:00Z",
       license = "CC_BY_4.0",
       access_restrictions = "none",
       update_frequency = "monthly",
       data_citation = "doi:10.1038/s41597-021-01234-x",
       curator = "Materials_Project_Team"
     }
   
   NAMESPACE SUPPORT:
   Qualified names enable organized metadata without conflicts:
     meta {
       experiment:temperature = 773,  (* K *)
       simulation:temperature = 800,  (* K *)
       analysis:confidence = 0.95,
       workflow:step = "optimization",
       quality:assessment = "validated"
     }
   
   INTEGRATION BENEFITS:
   - Seamless integration with laboratory information systems
   - Automatic metadata extraction for machine learning
   - Compliance with data management standards
   - Enhanced searchability and discoverability
   - Support for complex workflows and pipelines
   ============================================================================ *)
Meta ::= "meta" "{" MEntry ( "," MEntry )* "}" ;
MEntry ::= QName "=" ( Str | Num | Bool ) ; (* Meta values: string, number, or boolean. *)

/*----------------------------  DATA TYPES & TERMINALS -------------------------*/
(* ============================================================================
   COMPREHENSIVE TYPE SYSTEM WITH DIMENSIONAL ANALYSIS:
   
   AtomForge implements a sophisticated type system that combines traditional
   programming language types with scientific dimensional analysis, ensuring
   both computational correctness and physical validity.
   
   VECTOR TYPES:
   - Vec3: General 3D vectors (positions, forces, fields)
   - Vec3F: Fractional coordinates (typically [0,1] range)
   - Vec3I: Integer vectors (grid dimensions, supercell repeats)
   
   DIMENSIONED TYPES:
   All physical quantities support explicit unit specification:
   - Len: Length measurements with unit validation
   - Ang: Angular measurements in degrees or radians
   - Temp: Temperature with automatic conversion support
   - Pres: Pressure in various scientific units
   - Disp: Displacement parameters for thermal motion
   
   COORDINATE FRAMES:
   Explicit frame specification eliminates common coordination errors:
   - fractional: Coordinates in lattice vector basis [0,1]
   - cartesian: Coordinates in specified length units
   
   IDENTIFIERS & NAMING:
   - Regular identifiers: Standard programming language rules
   - Backticked identifiers: Support for special characters and keywords
   - Qualified names: Namespace support for complex specifications
   
   ADVANCED TYPE EXAMPLES:
   
   Dimensional Consistency:
     position = (0.5, 0.5, 0.0) fractional  (* Unitless fractional coords *)
     displacement = (1.2, 0.0, 0.0) cartesian angstrom  (* With units *)
     force = (0.01, 0.0, 0.0) cartesian "eV/angstrom"  (* Force vector *)
   
   Complex Identifiers:
     site `Cu-N-complex_1` { ... }  (* Special characters in backticks *)
     site `interface-layer` { ... }  (* Hyphenated identifiers *)
     property `σ_electrical` = 1e6  (* Unicode symbols *)
   
   Qualified Names:
     experiment:sample_id = "BTO_001"
     simulation:method = "DFT_PBE"
     analysis:confidence = 0.95
   
   TYPE VALIDATION:
   - Automatic unit conversion where appropriate
   - Dimensional consistency checking across expressions
   - Range validation for physical quantities
   - Frame compatibility verification
   - Element symbol validation against periodic table
   ============================================================================ *)
Vec3  ::= "(" Num "," Num "," Num ")" ; (* General 3D vector of Nums (can be Int or Float) *)
Vec3F ::= "(" Num "," Num "," Num ")" ; (* 3D vector typically for fractional coordinates (components can be Int or Float) *)
Vec3I ::= "(" Int "," Int "," Int ")" ; (* 3D vector of Integers *)
Len  ::= Num LenU? ;
Ang  ::= Num AngU? ;
Temp ::= Num TempU? ;
Pres ::= Num PresU? ;
Disp ::= Num DispU? ;
Frame ::= "fractional" | "cartesian" ; (* Coordinate frame specifier *)
Axis  ::= "x" | "y" | "z" ; (* Standard Cartesian axes *)

/*----------------------------  IDENTIFIERS & LEXICAL ELEMENTS -------------------------*/
Ident   ::= Letter ( Letter | Digit | "_" )* ; (* must not match any Keyword or Bool literal if not part of an assignment *)
BTIdent ::= "`" BTChar+ "`" ; (* Backticked identifier; for Idents that would clash with Keywords or contain special characters. *)
Id      ::= Ident | BTIdent ; (* General identifier for Site labels, etc. *)
QName   ::= ( Ident ":" )? Ident ; (* Qualified name (optional namespace) *)
Keyword ::= "atom_spec" | "header" | "units" | "type_system" | "lattice" | "symmetry" |
            "basis" | "site" | "emerging_materials" | "defects" | "tile" | "mirror" | "rotate" |
            "translate" | "matrix4" | "bonds" | "elastic" | "phonon" |
            "density_map" | "environment" | "ai_integration" | "procedural_generation" | "benchmarking" | "properties" | "validate" |
            "simplification" | "provenance" | "patch" | "add" | "remove" | "update" |
            "meta" | "true" | "false" | "fractional" | "cartesian" ;
            (* Note: 'true'/'false' are keywords when used as Bool literals. *)
            (* Keys in "key"=Value pairs (e.g. "dsl_version", "element", "description") are contextually reserved. *)

/*----------------------------  UNITS & PHYSICAL QUANTITIES -------------------------*/
(* ============================================================================
   COMPREHENSIVE UNIT SYSTEM:
   
   AtomForge supports an extensive range of scientific units covering all
   domains of materials science, from crystallography to electrochemistry
   to mechanical properties.
   
   LENGTH UNITS:
   - angstrom: Traditional crystallographic unit (10^-10 m)
   - nm: Nanometer (10^-9 m), common in nanotechnology
   - pm: Picometer (10^-12 m), high-precision measurements
   - bohr: Atomic unit of length (5.29 × 10^-11 m), quantum calculations
   
   ANGULAR UNITS:
   - degree: Traditional crystallographic unit (π/180 radians)
   - radian: Mathematical standard, computational preference
   
   TEMPERATURE UNITS:
   - K: Kelvin, absolute temperature scale
   
   PRESSURE UNITS:
   - Pa: Pascal, SI base unit
   - kPa, MPa, GPa: Common multiples for materials science
   - bar: Approximate atmospheric pressure (10^5 Pa)
   - atm: Standard atmosphere (101325 Pa)
   
   DISPLACEMENT UNITS:
   - angstrom^2: Squared length for atomic displacement parameters
   - pm^2, nm^2: Alternative length scales
   
   UNIT CONVERSION:
   AtomForge automatically handles unit conversions within expressions:
   - 1 angstrom = 0.1 nm = 100 pm = 1.889726 bohr
   - 1 degree = π/180 radians ≈ 0.017453 radians
   - 1 GPa = 10^9 Pa = 10^4 bar ≈ 9869 atm
   
   CUSTOM UNITS:
   Users can define custom units in the meta block for specialized applications:
   - Electrochemical units: V vs SHE, mAh/g
   - Spectroscopic units: cm^-1, THz, meV
   - Mechanical units: N/m, J/m^2, GPa⋅s
   ============================================================================ *)
LenU  ::= "angstrom" | "nm" | "pm" | "bohr" ;
AngU  ::= "degree" | "radian" ;
TempU ::= "K" ;
PresU ::= "Pa" | "kPa" | "bar" | "GPa" ;
DispU ::= "angstrom^2" ;

/*----------------------------  ENUMERATIONS & CONSTANTS -------------------------*/
(* ============================================================================
   CRYSTALLOGRAPHIC ENUMERATIONS:
   
   AtomForge provides comprehensive enumerations for all standard
   crystallographic concepts, ensuring consistency and validation.
   
   LATTICE TYPES:
   The seven crystal systems with their characteristic symmetries:
   - cubic: a=b=c, α=β=γ=90° (highest symmetry)
   - tetragonal: a=b≠c, α=β=γ=90° (uniaxial)
   - orthorhombic: a≠b≠c, α=β=γ=90° (three unique axes)
   - hexagonal: a=b≠c, α=β=90°, γ=120° (sixfold symmetry)
   - rhombohedral: a=b=c, α=β=γ≠90° (threefold symmetry)
   - monoclinic: a≠b≠c, α=γ=90°≠β (one unique angle)
   - triclinic: a≠b≠c, α≠β≠γ (lowest symmetry)
   
   SPACE GROUPS:
   - Integer: International Tables number (1-230)
   - String: Hermann-Mauguin symbol with full flexibility
   
   WYCKOFF POSITIONS:
   String representation allows all standard Wyckoff symbols:
   - Simple: "a", "b", "c", "d", ...
   - Complex: "8a", "16d", "24e", "48f", ...
   - Special: "1a", "2b", "3c", "4d", ...
   
   CHEMICAL ELEMENTS:
   Complete periodic table coverage from H to Og (1-118):
   - Light elements: H, He, Li, Be, B, C, N, O, F, Ne
   - Transition metals: Sc, Ti, V, Cr, Mn, Fe, Co, Ni, Cu, Zn
   - Lanthanides: La, Ce, Pr, Nd, Pm, Sm, Eu, Gd, Tb, Dy, Ho, Er, Tm, Yb, Lu
   - Actinides: Ac, Th, Pa, U, Np, Pu, Am, Cm, Bk, Cf, Es, Fm, Md, No, Lr
   - Synthetic: Rf, Db, Sg, Bh, Hs, Mt, Ds, Rg, Cn, Nh, Fl, Mc, Lv, Ts, Og
   
   VALIDATION FEATURES:
   - Element symbol spell-checking with suggestions
   - Space group number/symbol consistency verification
   - Lattice type geometric constraint enforcement
   - Wyckoff position compatibility with space group
   ============================================================================ *)
LatT ::= "cubic" | "tetragonal" | "orthorhombic" | "hexagonal" |
         "rhombohedral" | "monoclinic" | "triclinic" ;
SG   ::= Int | Str ; (* Space group number or Hermann-Mauguin symbol *)
Wyk  ::= Str ; (* Wyckoff symbol *)
Elem ::= "H"|"He"|"Li"|"Be"|"B"|"C"|"N"|"O"|"F"|"Ne"|"Na"|"Mg"|"Al"|"Si"|"P"|"S"|"Cl"|"Ar"|"K"|"Ca"|"Sc"|"Ti"|"V"|"Cr"|"Mn"|"Fe"|"Co"|"Ni"|"Cu"|"Zn"|"Ga"|"Ge"|"As"|"Se"|"Br"|"Kr"|"Rb"|"Sr"|"Y"|"Zr"|"Nb"|"Mo"|"Tc"|"Ru"|"Rh"|"Pd"|"Ag"|"Cd"|"In"|"Sn"|"Sb"|"Te"|"I"|"Xe"|"Cs"|"Ba"|"La"|"Ce"|"Pr"|"Nd"|"Pm"|"Sm"|"Eu"|"Gd"|"Tb"|"Dy"|"Ho"|"Er"|"Tm"|"Yb"|"Lu"|"Hf"|"Ta"|"W"|"Re"|"Os"|"Ir"|"Pt"|"Au"|"Hg"|"Tl"|"Pb"|"Bi"|"Po"|"At"|"Rn"|"Fr"|"Ra"|"Ac"|"Th"|"Pa"|"U"|"Np"|"Pu"|"Am"|"Cm"|"Bk"|"Cf"|"Es"|"Fm"|"Md"|"No"|"Lr"|"Rf"|"Db"|"Sg"|"Bh"|"Hs"|"Mt"|"Ds"|"Rg"|"Cn"|"Nh"|"Fl"|"Mc"|"Lv"|"Ts"|"Og" ;

Bool ::= "true" | "false" ; (* Now a distinct type usable in PVal, MEntry, Validation, etc. *)

/*----------------------------  PRIMITIVE LEXICAL ELEMENTS -------------------------*/
(* ============================================================================
   LEXICAL FOUNDATION:
   
   The primitive lexical elements provide the foundation for all higher-level
   constructs in AtomForge. These elements are designed for scientific
   computing with emphasis on precision and international compatibility.
   
   NUMERIC LITERALS:
   - Integer: Whole numbers for counting and indexing
   - Float: Real numbers with optional scientific notation
   - Precision: Automatic detection of required precision
   
   STRING LITERALS:
   - Unicode support: Full UTF-8 compatibility for international use
   - Escape sequences: Standard programming language escapes
   - Multiline support: For extensive documentation
   
   DATE FORMAT:
   - ISO 8601 profile: YYYY-MM-DD for international compatibility
   - Validation: Automatic checking for valid dates
   - Sortability: Lexicographic ordering matches chronological ordering
   
   CHARACTER SETS:
   - Letters: Full Unicode letter support
   - Digits: Standard ASCII digits 0-9
   - Symbols: Scientific and mathematical symbol support
   
   INTERNATIONALIZATION:
   - UTF-8 encoding throughout
   - Unicode identifiers support (where appropriate)
   - International date and number formats
   - Multilingual error messages (future extension)
   ============================================================================ *)
Num   ::= Float | Int ;
Int   ::= Digit+ ;
Float ::= Digit+ "." Digit+ Exp? | Digit+ Exp ;
Exp   ::= ( "e"|"E" ) ( "+"|"-" )? Digit+ ;
Digit ::= "0".."9" ;
Letter::= "A".."Z" | "a".."z" ;
Date  ::= Digit Digit Digit Digit "-" Digit Digit "-" Digit Digit ; (* YYYY-MM-DD (a profile of ISO 8601) *)

Str     ::= "\"" StrChar* "\"" ;
StrChar ::= "\\" EscSeq | AnyCharNoQuote ;
EscSeq  ::= "n" | "r" | "t" | "\\" | "\"" | "`" | "u" HexDigit HexDigit HexDigit HexDigit ;
HexDigit::= "0".."9" | "A".."F" | "a".."f" ;
BTChar  ::= "\\" EscSeq | AnyCharNoBack ;
AnyCharNoQuote ::= !('"'|'\\'|Newline) . ;
AnyCharNoBack   ::= !('`'|'\\'|Newline) . ;
Newline ::= "\r"? "\n" ;

(* End AtomForge DSL *)